Initialize the program!
Verify Test Cases
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcRunning test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3 4 5 6 9 13 14 15 17 18 20 22 23 25  > __res
All passed!
Done Verification
Generating repair candidates!
Processing src/kwsearch.c
Total 2492 different repair candidate templates!!!!
Total 5129 different repair candidate!!!
Trying different candidates!
BasicTester pointer: 0x2327640
CondTester pointer: 0x21c9c60
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:42
--Src File: src/kwsearch.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__abst_hole(match_icase, pattern, pat, psize, size, kwset, beg, lim, end, err)))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;


CondTester, a patch instance with id 0:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:70
--Src File: src/kwsearch.c
Fragment 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__abst_hole(beg, end, err, kwset, lim, pat, psize, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 1:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:76
--Src File: src/kwsearch.c
Fragment 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__abst_hole(err, kwset, beg, pat, psize, lim, end, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 2:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:76
--Src File: src/kwsearch.c
Fragment 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__abst_hole(err, kwset, beg, pat, psize, lim, end, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 3:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((offset == (size_t)-1) && !(__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    goto failure;


CondTester, a patch instance with id 4:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) && !(__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((offset == (size_t)-1) || (__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    goto failure;


CondTester, a patch instance with id 5:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) || (__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:70
--Src File: src/kwsearch.c
Fragment 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__abst_hole(beg, end, err, kwset, lim, pat, psize, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 6:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:42
--Src File: src/kwsearch.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__abst_hole(match_icase, pattern, pat, psize, size, kwset, beg, lim, end, err)))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;


CondTester, a patch instance with id 7:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:54
--Src File: src/kwsearch.c
Fragment 0:
if ((lim >= pat + psize) && !(__abst_hole(lim, pat, psize, end, beg, pattern, match_icase, size, kwset, err)))
    break;


CondTester, a patch instance with id 8:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:56
--Src File: src/kwsearch.c
Fragment 0:
if ((*lim == '\n') && !(__abst_hole(lim, pat, psize, end, beg, pattern, err, match_icase, kwset, size))) {
    lim++;
    break;
}


CondTester, a patch instance with id 9:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:56
--Src File: src/kwsearch.c
Fragment 0:
if ((*lim == '\n') || (__abst_hole(lim, pat, psize, end, beg, pattern, err, match_icase, kwset, size))) {
    lim++;
    break;
}


CondTester, a patch instance with id 10:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((match_icase) && !(__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 11:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((match_icase) || (__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 12:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 13:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 14:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:54
--Src File: src/kwsearch.c
Fragment 0:
if ((lim >= pat + psize) || (__abst_hole(lim, pat, psize, end, beg, pattern, match_icase, size, kwset, err)))
    break;


CondTester, a patch instance with id 15:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:42
--Src File: src/kwsearch.c
Fragment 0:
if (((match_icase) || (__abst_hole(match_icase, pattern, pat, psize, size, kwset, beg, lim, end, err))) && (__ctype_get_mb_cur_max()) > 1)
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;


CondTester, a patch instance with id 16:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((match_icase) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err)))) && (__ctype_get_mb_cur_max()) > 1)
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((mb_start == s0) && !(__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    goto failure;


CondTester, a patch instance with id 17:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((mb_start == s0) && !(__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((mb_start == s0) || (__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    goto failure;


CondTester, a patch instance with id 18:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((mb_start == s0) || (__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:109
--Src File: src/kwsearch.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__abst_hole(buf, size, beg, mb_start, offset, s0, kwset, start_ptr, len, match_words, match_lines, eol, match_icase, try, eolbyte, ret_val, end, match_size))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}


CondTester, a patch instance with id 19:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:109
--Src File: src/kwsearch.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__abst_hole(buf, size, beg, mb_start, offset, s0, kwset, start_ptr, len, match_words, match_lines, eol, match_icase, try, eolbyte, ret_val, end, match_size))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}


CondTester, a patch instance with id 20:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:109
--Src File: src/kwsearch.c
Fragment 0:
if ((((__ctype_get_mb_cur_max()) > 1) || (__abst_hole(buf, size, beg, mb_start, offset, s0, kwset, start_ptr, len, match_words, match_lines, eol, match_icase, try, eolbyte, ret_val, end, match_size))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}


CondTester, a patch instance with id 21:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if ((((__ctype_get_mb_cur_max()) > 1) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 12472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(kwset, size, psize, match_icase, pattern, pat, beg, lim, end, err)))
    return;
kwsinit(&kwset);


CondTester, a patch instance with id 22:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
if ((__is_neg(10, &(kwset), sizeof (kwset), &(size), sizeof (size), &(psize), sizeof (psize), &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
    return;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 11241
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    return -1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 23:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return -1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 11241
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    return 0;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 24:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 0;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 11241
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    return 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 25:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 9980
At location src/kwsearch.c:53
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(end, lim, pat, psize, beg, pattern, match_icase, size, kwset, err)))
    return;
end = lim;


CondTester, a patch instance with id 26:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  
//Patch 0:
if ((__is_neg(10, &(end), sizeof (end), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    return;
end = lim;

//CodeSeg 1:
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 9980
At location src/kwsearch.c:53
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(end, lim, pat, psize, beg, pattern, match_icase, size, kwset, err)))
    break;
end = lim;


CondTester, a patch instance with id 27:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  
//Patch 0:
if ((__is_neg(10, &(end), sizeof (end), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;
end = lim;

//CodeSeg 1:
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 9978
At location src/kwsearch.c:51
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(beg, lim, end, pat, psize, pattern, match_icase, size, kwset, err)))
    break;
for (lim = beg;; ++lim) {
    end = lim;
    if (lim >= pat + psize)
        break;
    if (*lim == '\n') {
        lim++;
        break;
    }
}


CondTester, a patch instance with id 28:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      
//Patch 0:
if ((__is_neg(10, &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;
for (lim = beg;; ++lim) {
    end = lim;
    if (lim >= pat + psize)
        break;
    if (*lim == '\n') {
        lim++;
        break;
    }
}

//CodeSeg 1:

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 9978
At location src/kwsearch.c:51
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(beg, lim, end, pat, psize, pattern, match_icase, size, kwset, err)))
    return;
for (lim = beg;; ++lim) {
    end = lim;
    if (lim >= pat + psize)
        break;
    if (*lim == '\n') {
        lim++;
        break;
    }
}


CondTester, a patch instance with id 29:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      
//Patch 0:
if ((__is_neg(10, &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    return;
for (lim = beg;; ++lim) {
    end = lim;
    if (lim >= pat + psize)
        break;
    if (*lim == '\n') {
        lim++;
        break;
    }
}

//CodeSeg 1:

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 8949
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    goto failure;
if (mb_start == s0)
    goto failure;


CondTester, a patch instance with id 30:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 8949
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    goto success;
if (mb_start == s0)
    goto failure;


CondTester, a patch instance with id 31:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 8949
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    goto success_in_beg_and_len;
if (mb_start == s0)
    goto failure;


CondTester, a patch instance with id 32:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success_in_beg_and_len;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with CondTester:
Priority 8949
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    goto out;
if (mb_start == s0)
    goto failure;


CondTester, a patch instance with id 33:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto out;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 8948
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    goto failure;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 34:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with CondTester:
Priority 8948
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    goto success;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 35:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with CondTester:
Priority 8948
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    goto success_in_beg_and_len;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 36:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success_in_beg_and_len;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with CondTester:
Priority 8948
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    goto out;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 37:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto out;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with CondTester:
Priority 8944
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    goto failure;
if (offset == (size_t)-1)
    goto failure;


CondTester, a patch instance with id 38:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:39
Preprocess the following candidate with CondTester:
Priority 8944
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    goto success_in_beg_and_len;
if (offset == (size_t)-1)
    goto failure;


CondTester, a patch instance with id 39:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto success_in_beg_and_len;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:40
Preprocess the following candidate with CondTester:
Priority 8944
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    goto out;
if (offset == (size_t)-1)
    goto failure;


CondTester, a patch instance with id 40:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto out;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:41
Preprocess the following candidate with CondTester:
Priority 8944
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    goto success;
if (offset == (size_t)-1)
    goto failure;


CondTester, a patch instance with id 41:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto success;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:42
Preprocess the following candidate with CondTester:
Priority 8941
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    goto failure;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 42:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:43
Preprocess the following candidate with CondTester:
Priority 8941
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    goto success;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 43:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:44
Preprocess the following candidate with CondTester:
Priority 8941
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    goto out;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 44:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto out;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:45
Preprocess the following candidate with CondTester:
Priority 8941
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    goto success_in_beg_and_len;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 45:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success_in_beg_and_len;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 8749
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    return -1;
if (mb_start == s0)
    goto failure;


CondTester, a patch instance with id 46:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return -1;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:47
Preprocess the following candidate with CondTester:
Priority 8749
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    return 0;
if (mb_start == s0)
    goto failure;


CondTester, a patch instance with id 47:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 0;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:48
Preprocess the following candidate with CondTester:
Priority 8749
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    return 1;
if (mb_start == s0)
    goto failure;


CondTester, a patch instance with id 48:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 1;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:49
Preprocess the following candidate with CondTester:
Priority 8749
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    break;
if (mb_start == s0)
    goto failure;


CondTester, a patch instance with id 49:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    break;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 50
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((mb_start == s0) && !(__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      goto failure;
	  }
	  else if (__get_mutant()==1) {
	  if ((mb_start == s0) || (__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      goto failure;
	  }
	  else if (__get_mutant()==2) {
	  if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      goto failure;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==3) {
	  if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      goto success;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==4) {
	  if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      goto success_in_beg_and_len;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==5) {
	  if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      goto out;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==6) {
	  if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      return -1;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==7) {
	  if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      return 0;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==8) {
	  if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      return 1;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==9) {
	  if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      break;
	  if (mb_start == s0)
	      goto failure;
	  }
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 17:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((mb_start == s0) && !(__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 18:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((mb_start == s0) || (__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 30:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 31:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 32:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success_in_beg_and_len;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Testing instance id 33:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto out;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 46:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return -1;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 47:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 0;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 48:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 1;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 49:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    break;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Postprocessing instance id 32:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success_in_beg_and_len;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr len == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr try == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr start_ptr == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr match_words == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr match_lines == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr ret_val == 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr size == 4
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr offset == 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr eol == 10
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr eolbyte == 10
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Initial synthesize failed, final attempt
Final attempt 1/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  //prophet generated patch
	  if (((0)))
	      goto success_in_beg_and_len;
	  if (mb_start == s0)
	      goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcTrying Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Final attempt 2/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  //prophet generated patch
	  if (((1)))
	      goto success_in_beg_and_len;
	  if (mb_start == s0)
	      goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcTrying Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Postprocessing failed!
Counter: 51
Batcher Size:40
Preprocess the following candidate with CondTester:
Priority 8748
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    return -1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 50:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return -1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:41
Preprocess the following candidate with CondTester:
Priority 8748
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    return 0;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 51:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 0;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:42
Preprocess the following candidate with CondTester:
Priority 8748
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size)))
    return 1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 52:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:43
Preprocess the following candidate with CondTester:
Priority 8744
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    return -1;
if (offset == (size_t)-1)
    goto failure;


CondTester, a patch instance with id 53:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    return -1;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:44
Preprocess the following candidate with CondTester:
Priority 8744
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    return 0;
if (offset == (size_t)-1)
    goto failure;


CondTester, a patch instance with id 54:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    return 0;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:45
Preprocess the following candidate with CondTester:
Priority 8744
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    return 1;
if (offset == (size_t)-1)
    goto failure;


CondTester, a patch instance with id 55:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    return 1;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 8744
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    break;
if (offset == (size_t)-1)
    goto failure;


CondTester, a patch instance with id 56:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    break;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 57
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((offset == (size_t)-1) && !(__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          goto failure;
      }
      else if (__get_mutant()==1) {
      if ((offset == (size_t)-1) || (__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          goto failure;
      }
      else if (__get_mutant()==2) {
      if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          goto failure;
      if (offset == (size_t)-1)
          goto failure;
      }
      else if (__get_mutant()==3) {
      if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          goto success_in_beg_and_len;
      if (offset == (size_t)-1)
          goto failure;
      }
      else if (__get_mutant()==4) {
      if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          goto out;
      if (offset == (size_t)-1)
          goto failure;
      }
      else if (__get_mutant()==5) {
      if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          goto success;
      if (offset == (size_t)-1)
          goto failure;
      }
      else if (__get_mutant()==6) {
      if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          return -1;
      if (offset == (size_t)-1)
          goto failure;
      }
      else if (__get_mutant()==7) {
      if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          return 0;
      if (offset == (size_t)-1)
          goto failure;
      }
      else if (__get_mutant()==8) {
      if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          return 1;
      if (offset == (size_t)-1)
          goto failure;
      }
      else if (__get_mutant()==9) {
      if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          break;
      if (offset == (size_t)-1)
          goto failure;
      }
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 4:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) && !(__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 5:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) || (__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 38:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 39:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto success_in_beg_and_len;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 40:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto out;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 41:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto success;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Testing instance id 53:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    return -1;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 54:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    return 0;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 55:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    return 1;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 56:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    break;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Postprocessing instance id 41:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto success;
if (offset == (size_t)-1)
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr start_ptr == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_words == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Passed!
Passed with updated best score 8943959.000000
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  //prophet generated patch
  if (__get_mutant()==0) {
  if ((__is_neg(10, &(kwset), sizeof (kwset), &(size), sizeof (size), &(psize), sizeof (psize), &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
      return;
  kwsinit(&kwset);
  }
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 22:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
if ((__is_neg(10, &(kwset), sizeof (kwset), &(size), sizeof (size), &(psize), sizeof (psize), &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
    return;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Postprocessing instance id 22:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
if ((__is_neg(10, &(kwset), sizeof (kwset), &(size), sizeof (size), &(psize), sizeof (psize), &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
    return;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr kwset == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr err == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr end != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr size == 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Passed!
Passed with updated best score 12471978.000000
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
      pat = mbtolower(pattern, &psize);
  else
      pat = pattern;
  }
  else if (__get_mutant()==1) {
  if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
      pat = mbtolower(pattern, &psize);
  else
      pat = pattern;
  }
  else if (__get_mutant()==2) {
  if (((match_icase) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err)))) && (__ctype_get_mb_cur_max()) > 1)
      pat = mbtolower(pattern, &psize);
  else
      pat = pattern;
  }

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcSingle building for Tester 0x21c9c60 id 0 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcSingle building for Tester 0x21c9c60 id 7 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcSingle building for Tester 0x21c9c60 id 16 failed as well!
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((__is_neg(10, &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
          break;
      for (lim = beg;; ++lim) {
          end = lim;
          if (lim >= pat + psize)
              break;
          if (*lim == '\n') {
              lim++;
              break;
          }
      }
      }
      else if (__get_mutant()==1) {
      if ((__is_neg(10, &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
          return;
      for (lim = beg;; ++lim) {
          end = lim;
          if (lim >= pat + psize)
              break;
          if (*lim == '\n') {
              lim++;
              break;
          }
      }
      }

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 28:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      
//Patch 0:
if ((__is_neg(10, &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;
for (lim = beg;; ++lim) {
    end = lim;
    if (lim >= pat + psize)
        break;
    if (*lim == '\n') {
        lim++;
        break;
    }
}

//CodeSeg 1:

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 29:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      
//Patch 0:
if ((__is_neg(10, &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    return;
for (lim = beg;; ++lim) {
    end = lim;
    if (lim >= pat + psize)
        break;
    if (*lim == '\n') {
        lim++;
        break;
    }
}

//CodeSeg 1:

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((__is_neg(10, &(end), sizeof (end), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
	      return;
	  end = lim;
	  }
	  else if (__get_mutant()==1) {
	  if ((__is_neg(10, &(end), sizeof (end), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
	      break;
	  end = lim;
	  }
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 26:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  
//Patch 0:
if ((__is_neg(10, &(end), sizeof (end), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    return;
end = lim;

//CodeSeg 1:
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 27:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  
//Patch 0:
if ((__is_neg(10, &(end), sizeof (end), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;
end = lim;

//CodeSeg 1:
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Branch 1: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Branch 1: 1
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Postprocessing instance id 27:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  
//Patch 0:
if ((__is_neg(10, &(end), sizeof (end), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;
end = lim;

//CodeSeg 1:
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((lim >= pat + psize) && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
	      break;
	  }
	  else if (__get_mutant()==1) {
	  if ((lim >= pat + psize) || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
	      break;
	  }
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 8:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 15:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 //prophet generated patch
	 if (__get_mutant()==0) {
	 if ((*lim == '\n') && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
	     lim++;
	     break;
	 }
	 }
	 else if (__get_mutant()==1) {
	 if ((*lim == '\n') || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
	     lim++;
	     break;
	 }
	 }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 9:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 10:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      //prophet generated patch
      if (__get_mutant()==0) {
      if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
          error(EXIT_TROUBLE, 0, "%s", err);
      }
      else if (__get_mutant()==1) {
      if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
          error(EXIT_TROUBLE, 0, "%s", err);
      }
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 1:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 6:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Postprocessing instance id 6:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr err == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize == 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Passed!
Passed with updated best score 19999994.000000
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  //prophet generated patch
  if (__get_mutant()==0) {
  if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
      error(EXIT_TROUBLE, 0, "%s", err);
  }
  else if (__get_mutant()==1) {
  if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
      error(EXIT_TROUBLE, 0, "%s", err);
  }
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 2:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 3:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Postprocessing instance id 3:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr err == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize == 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Passed!
Passed with updated best score 19999997.000000
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
      return -1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
      return 0;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
      return 1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
      goto failure;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
      goto success;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
      goto out;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
      goto success_in_beg_and_len;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 13:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 14:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 23:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return -1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 24:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 0;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 25:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 42:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 43:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Testing instance id 44:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto out;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Testing instance id 45:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success_in_beg_and_len;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Postprocessing instance id 43:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Postprocessing failed!
CondTester, Postprocessing instance id 44:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto out;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Postprocessing failed!
CondTester, Postprocessing instance id 45:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success_in_beg_and_len;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((match_icase) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==1) {
      if ((match_icase) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==2) {
      if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
          goto failure;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==3) {
      if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
          goto success;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==4) {
      if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
          goto success_in_beg_and_len;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==5) {
      if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
          goto out;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==6) {
      if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
          return -1;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==7) {
      if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
          return 0;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==8) {
      if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
          return 1;
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 11:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 12:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 34:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 35:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Testing instance id 36:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success_in_beg_and_len;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Testing instance id 37:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto out;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Testing instance id 50:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return -1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 51:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 0;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 52:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    return 1;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Postprocessing instance id 35:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Postprocessing failed!
CondTester, Postprocessing instance id 36:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto success_in_beg_and_len;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Postprocessing failed!
CondTester, Postprocessing instance id 37:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto out;
if (match_icase) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      //prophet generated patch
      if (__get_mutant()==0) {
      if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          if (mb_start == s0)
              goto failure;
          beg = mb_start - 1;
          continue;
      }
      }
      else if (__get_mutant()==1) {
      if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          if (mb_start == s0)
              goto failure;
          beg = mb_start - 1;
          continue;
      }
      }
      else if (__get_mutant()==2) {
      if ((((__ctype_get_mb_cur_max()) > 1) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
          if (mb_start == s0)
              goto failure;
          beg = mb_start - 1;
          continue;
      }
      }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 19:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 20:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 21:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if ((((__ctype_get_mb_cur_max()) > 1) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Total cnt of passed cond schemas: 12
Total cnt of cond schemas: 57
Counter: 58
Batcher Size:0
The found score 19999997.000000 is greater than current score 7491.000000!
Terminate current session!
Generated a patch at candidate schema no 4
Total cnt of passed cond schemas: 12
Total cnt of cond schemas: 57
Candidate count:0!!
Found a fix! Store to: grep-fix-db9d6340-6d952beesrc_kwsearch.c
Found a fix! Store to: grep-fix-db9d6340-6d952beesrc_kwsearch.c-1
Found a fix! Store to: grep-fix-db9d6340-6d952beesrc_kwsearch.c-2
Found a fix! Store to: grep-fix-db9d6340-6d952beesrc_kwsearch.c-3
Repair process ends successfully!
Total 2492 different repair candidate schema!!!!
Total number of compiles: 53
Total number of test eval: 595
