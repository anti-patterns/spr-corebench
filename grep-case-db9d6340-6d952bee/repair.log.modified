Initialize the program!
Verify Test Cases
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcRunning test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3 4 5 6 9 13 14 15 17 18 20 22 23 25  > __res
All passed!
Done Verification
Generating repair candidates!
Processing src/kwsearch.c
Total 2354 different repair candidate templates!!!!
Total 2970 different repair candidate!!!
Trying different candidates!
BasicTester pointer: 0x296d170
CondTester pointer: 0x29dabe0
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:42
--Src File: src/kwsearch.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__abst_hole(match_icase, pattern, pat, psize, size, kwset, beg, lim, end, err)))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;


CondTester, a patch instance with id 0:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:76
--Src File: src/kwsearch.c
Fragment 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__abst_hole(err, kwset, beg, pat, psize, lim, end, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 1:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:76
--Src File: src/kwsearch.c
Fragment 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__abst_hole(err, kwset, beg, pat, psize, lim, end, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 2:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((offset == (size_t)-1) && !(__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    goto failure;


CondTester, a patch instance with id 3:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) && !(__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:105
--Src File: src/kwsearch.c
Fragment 0:
if ((offset == (size_t)-1) || (__abst_hole(offset, buf, size, beg, kwset, start_ptr, mb_start, len, match_icase, match_words, match_lines, eol, eolbyte, try, ret_val, end, match_size, kwsmatch.index)))
    goto failure;


CondTester, a patch instance with id 4:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) || (__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:42
--Src File: src/kwsearch.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__abst_hole(match_icase, pattern, pat, psize, size, kwset, beg, lim, end, err)))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;


CondTester, a patch instance with id 5:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:56
--Src File: src/kwsearch.c
Fragment 0:
if ((*lim == '\n') && !(__abst_hole(lim, pat, psize, end, beg, pattern, err, match_icase, kwset, size))) {
    lim++;
    break;
}


CondTester, a patch instance with id 6:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:70
--Src File: src/kwsearch.c
Fragment 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__abst_hole(beg, end, err, kwset, lim, pat, psize, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 7:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:70
--Src File: src/kwsearch.c
Fragment 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__abst_hole(beg, end, err, kwset, lim, pat, psize, pattern, match_icase, size)))
    error(EXIT_TROUBLE, 0, "%s", err);


CondTester, a patch instance with id 8:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:56
--Src File: src/kwsearch.c
Fragment 0:
if ((*lim == '\n') || (__abst_hole(lim, pat, psize, end, beg, pattern, err, match_icase, kwset, size))) {
    lim++;
    break;
}


CondTester, a patch instance with id 9:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((match_icase) && !(__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 10:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:92
--Src File: src/kwsearch.c
Fragment 0:
if ((match_icase) || (__abst_hole(match_icase, buf, size, start_ptr, eolbyte, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}


CondTester, a patch instance with id 11:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 12:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__abst_hole(match_icase, buf, size, eolbyte, start_ptr, beg, mb_start, kwset, len, match_words, match_lines, eol, try, ret_val, end, match_size))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


CondTester, a patch instance with id 13:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:42
--Src File: src/kwsearch.c
Fragment 0:
if (((match_icase) || (__abst_hole(match_icase, pattern, pat, psize, size, kwset, beg, lim, end, err))) && (__ctype_get_mb_cur_max()) > 1)
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;


CondTester, a patch instance with id 14:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((match_icase) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err)))) && (__ctype_get_mb_cur_max()) > 1)
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;

//CodeSeg 1:

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:54
--Src File: src/kwsearch.c
Fragment 0:
if ((lim >= pat + psize) && !(__abst_hole(lim, pat, psize, end, beg, pattern, match_icase, size, kwset, err)))
    break;


CondTester, a patch instance with id 15:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:54
--Src File: src/kwsearch.c
Fragment 0:
if ((lim >= pat + psize) || (__abst_hole(lim, pat, psize, end, beg, pattern, match_icase, size, kwset, err)))
    break;


CondTester, a patch instance with id 16:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((mb_start == s0) && !(__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    goto failure;


CondTester, a patch instance with id 17:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((mb_start == s0) && !(__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
if ((mb_start == s0) || (__abst_hole(mb_start, s0, buf, size, beg, offset, len, kwset, start_ptr, match_words, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
    goto failure;


CondTester, a patch instance with id 18:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((mb_start == s0) || (__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:109
--Src File: src/kwsearch.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__abst_hole(buf, size, beg, mb_start, offset, s0, kwset, start_ptr, len, match_words, match_lines, eol, match_icase, try, eolbyte, ret_val, end, match_size))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}


CondTester, a patch instance with id 19:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:109
--Src File: src/kwsearch.c
Fragment 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__abst_hole(buf, size, beg, mb_start, offset, s0, kwset, start_ptr, len, match_words, match_lines, eol, match_icase, try, eolbyte, ret_val, end, match_size))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}


CondTester, a patch instance with id 20:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 20000
At location src/kwsearch.c:109
--Src File: src/kwsearch.c
Fragment 0:
if ((((__ctype_get_mb_cur_max()) > 1) || (__abst_hole(buf, size, beg, mb_start, offset, s0, kwset, start_ptr, len, match_words, match_lines, eol, match_icase, try, eolbyte, ret_val, end, match_size))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}


CondTester, a patch instance with id 21:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if ((((__ctype_get_mb_cur_max()) > 1) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
try = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 0:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
xalloc_die();
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 1:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
xalloc_die();
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = end - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 2:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = beg - (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 3:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
start_ptr = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 4:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
try = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 5:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
try = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 6:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
try = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 7:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 30
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  try = (try);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  xalloc_die();
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  len = end - beg;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  ret_val = beg - (end);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  start_ptr = (mb_start);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  try = (buf);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  try = (mb_start);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==9) {
  try = (start_ptr);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 12:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 13:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(eolbyte), sizeof (eolbyte), &(start_ptr), sizeof (start_ptr), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 0:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 1:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
xalloc_die();
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 2:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 3:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 4:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 5:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 6:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 7:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 31
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
try = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 8:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
start_ptr = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 9:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
start_ptr = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 10:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
try = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 11:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = beg - (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 12:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = beg - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 13:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
start_ptr = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 14:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
start_ptr = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 15:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
start_ptr = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 16:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = beg - (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 17:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 40
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  try = (end);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  start_ptr = (start_ptr);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  start_ptr = (try);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  try = (beg);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  ret_val = beg - (mb_start);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  ret_val = beg - buf;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  start_ptr = (buf);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  start_ptr = (end);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  start_ptr = (beg);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==9) {
  ret_val = beg - (start_ptr);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 8:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 9:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 10:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 11:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
try = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 12:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 13:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 14:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 15:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 16:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
start_ptr = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 17:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 41
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = beg - (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 18:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = kwsmatch.size[0];
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 19:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = kwsmatch.size[0];
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (len);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 20:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (len);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (start_ptr) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 21:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (start_ptr) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = beg - (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 22:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = beg - (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 23:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (try) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 24:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (try) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (mb_start) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 25:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (mb_start) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (ret_val);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 26:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (ret_val);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (size);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 27:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (size);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 50
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  ret_val = beg - (try);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  len = kwsmatch.size[0];
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  ret_val = (len);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  ret_val = (start_ptr) - buf;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  ret_val = beg - (beg);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  ret_val = beg - (buf);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  ret_val = (try) - buf;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  ret_val = (mb_start) - buf;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  ret_val = (ret_val);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==9) {
  ret_val = (size);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 18:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 19:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = kwsmatch.size[0];
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 20:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (len);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 21:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (start_ptr) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 22:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 23:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = beg - (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 24:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (try) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 25:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (mb_start) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 26:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (ret_val);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 27:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (size);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 51
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (-1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 28:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (-1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 29:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (buf) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 30:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (buf) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (end) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 31:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (end) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (beg) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 32:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (beg) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
ret_val = (0);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 33:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (0);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 34:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 35:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (start_ptr) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 36:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (start_ptr) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = end - (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 37:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 60
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  ret_val = (-1);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  ret_val = (1);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  ret_val = (buf) - buf;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  ret_val = (end) - buf;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  ret_val = (beg) - buf;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  ret_val = (0);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  end = (start_ptr);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  len = (1);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  len = (start_ptr) - beg;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==9) {
  len = end - (end);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 28:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (-1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 29:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 30:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (buf) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 31:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (end) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 32:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (beg) - buf;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 33:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
ret_val = (0);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 34:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 35:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 36:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (start_ptr) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 37:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 61
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = end - (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 38:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = end - (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 39:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = end - (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 40:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 63
Counter: 64
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (try) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 41:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (try) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 64
Counter: 65
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = end - (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 42:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 65
Counter: 66
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = end - (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 43:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 66
Counter: 67
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (beg) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 44:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (beg) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 67
Counter: 68
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (len);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 45:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (len);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 68
Counter: 69
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (ret_val);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 46:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (ret_val);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 69
Counter: 70
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (size);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 47:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (size);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 70
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  len = end - (start_ptr);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  len = end - (try);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  len = end - (mb_start);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  len = (try) - beg;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  len = end - (beg);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  len = end - (buf);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  len = (beg) - beg;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  len = (len);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  len = (ret_val);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==9) {
  len = (size);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 38:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 39:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 40:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 41:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (try) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 42:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 43:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = end - (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 44:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (beg) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 45:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (len);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 46:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (ret_val);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 47:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (size);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 71
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (mb_start) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 48:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (mb_start) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 71
Counter: 72
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (buf) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 49:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (buf) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 72
Counter: 73
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (end) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 50:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (end) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 73
Counter: 74
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (start_ptr) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 51:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (start_ptr) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 74
Counter: 75
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (end));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 52:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (end));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 75
Counter: 76
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
if ((end = memchr(beg + len, eol, (buf + size) - (beg + len))) != ((void *)0))
    end++;
else
    end = buf + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 53:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((end = memchr(beg + len, eol, (buf + size) - (beg + len))) != ((void *)0))
    end++;
else
    end = buf + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 76
Counter: 77
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (-1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 54:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (-1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 77
Counter: 78
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
len = (0);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 55:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (0);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 78
Counter: 79
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
kwsinit(&kwset);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 56:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
kwsinit(&kwset);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 79
Counter: 80
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (mb_start));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 57:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (mb_start));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 80
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  len = (mb_start) - beg;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  len = (buf) - beg;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  len = (end) - beg;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  end = (start_ptr) + size;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  error(EXIT_TROUBLE, 0, "%s", (end));
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  if ((end = memchr(beg + len, eol, (buf + size) - (beg + len))) != ((void *)0))
      end++;
  else
      end = buf + size;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  len = (-1);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  len = (0);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  kwsinit(&kwset);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==9) {
  error(EXIT_TROUBLE, 0, "%s", (mb_start));
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 48:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (mb_start) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 49:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (buf) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 50:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (end) - beg;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 51:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (start_ptr) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 52:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (end));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 53:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
if ((end = memchr(beg + len, eol, (buf + size) - (beg + len))) != ((void *)0))
    end++;
else
    end = buf + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 54:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (-1);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 55:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
len = (0);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 56:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
kwsinit(&kwset);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 57:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (mb_start));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Counter: 81
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (start_ptr));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 58:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (start_ptr));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 81
Counter: 82
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (try));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 59:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (try));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 82
Counter: 83
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 60:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 83
Counter: 84
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = buf + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 61:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = buf + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 84
Counter: 85
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (beg));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 62:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (beg));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 85
Counter: 86
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (buf));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 63:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (buf));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 86
Counter: 87
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 64:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 87
Counter: 88
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (try) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 65:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (try) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 88
Counter: 89
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
(beg)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 66:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(beg)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 89
Counter: 90
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
(buf)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 67:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(buf)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 90
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  error(EXIT_TROUBLE, 0, "%s", (start_ptr));
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  error(EXIT_TROUBLE, 0, "%s", (try));
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  end = (try);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  end = buf + size;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  error(EXIT_TROUBLE, 0, "%s", (beg));
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  error(EXIT_TROUBLE, 0, "%s", (buf));
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  end++;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  end = (try) + size;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  (beg)++;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==9) {
  (buf)++;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 58:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (start_ptr));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 59:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (try));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 60:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 61:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = buf + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 62:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (beg));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 63:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (buf));
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 64:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 65:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (try) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 66:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(beg)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 67:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(buf)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 91
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (try) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 68:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (try) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 91
Counter: 92
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 69:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 92
Counter: 93
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 70:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 93
Counter: 94
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 71:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 94
Counter: 95
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (mb_start) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 72:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (mb_start) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 95
Counter: 96
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (end) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 73:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (end) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 96
Counter: 97
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (beg) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 74:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (beg) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 97
Counter: 98
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 75:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 98
Counter: 99
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
end = (buf) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 76:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (buf) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 99
Counter: 100
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = mb_start - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 77:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = mb_start - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 100
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  beg = (try) - 1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  end = (beg);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  end = (end);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  end = (mb_start);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  end = (mb_start) + size;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  end = (end) + size;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  end = (beg) + size;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  end = (buf);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  end = (buf) + size;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==9) {
  beg = mb_start - 1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 68:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (try) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 69:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 70:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 71:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 72:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (mb_start) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 73:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (end) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 74:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (beg) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 75:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 76:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
end = (buf) + size;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 77:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = mb_start - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 101
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
buf = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 78:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 101
Counter: 102
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
buf = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 79:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 102
Counter: 103
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
buf = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 80:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 103
Counter: 104
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
buf = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 81:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 104
Counter: 105
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
buf = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 82:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 105
Counter: 106
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
buf = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 83:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 106
Counter: 107
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
(end)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 84:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(end)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 107
Counter: 108
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (buf) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 85:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (buf) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 108
Counter: 109
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (mb_start) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 86:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (mb_start) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 109
Counter: 110
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (start_ptr) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 87:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (start_ptr) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 110
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  buf = (end);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  buf = (start_ptr);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  buf = (try);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  buf = (mb_start);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  buf = (beg);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  buf = (buf);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  (end)++;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  beg = (buf) - 1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  beg = (mb_start) - 1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==9) {
  beg = (start_ptr) - 1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 78:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 79:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 80:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 81:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 82:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 83:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
buf = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 84:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(end)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 85:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (buf) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 86:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (mb_start) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 87:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (start_ptr) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 111
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 88:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 111
Counter: 112
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 89:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 112
Counter: 113
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 90:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 113
Counter: 114
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (end) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 91:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (end) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 114
Counter: 115
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 92:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 115
Counter: 116
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
(mb_start)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 93:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(mb_start)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 116
Counter: 117
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
(try)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 94:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(try)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 117
Counter: 118
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (beg) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 95:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (beg) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 118
Counter: 119
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 96:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 119
Counter: 120
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
beg = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 97:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 120
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  beg = (try);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==1) {
  beg = (start_ptr);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==2) {
  beg = (end);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==3) {
  beg = (end) - 1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==4) {
  beg = (mb_start);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==5) {
  (mb_start)++;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==6) {
  (try)++;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==7) {
  beg = (beg) - 1;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==8) {
  beg = (buf);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
  else if (__get_mutant()==9) {
  beg = (beg);
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 88:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (try);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 89:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (start_ptr);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 90:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (end);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 91:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (end) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 92:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (mb_start);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 93:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(mb_start)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 94:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(try)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 95:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (beg) - 1;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 96:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (buf);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 97:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
beg = (beg);
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 121
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7491
At location src/kwsearch.c:90
--Src File: src/kwsearch.c
Fragment 0:
(start_ptr)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}


BasicTester, a patch instance with id 98:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(start_ptr)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 121
Counter: 122
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
beg = (lim);
kwsinit(&kwset);


BasicTester, a patch instance with id 99:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (lim);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 122
Counter: 123
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
beg = pat;
kwsinit(&kwset);


BasicTester, a patch instance with id 100:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = pat;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 123
Counter: 124
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
end = (end);
kwsinit(&kwset);


BasicTester, a patch instance with id 101:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (end);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 124
Counter: 125
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
end = (err);
kwsinit(&kwset);


BasicTester, a patch instance with id 102:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 125
Counter: 126
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
end = (beg);
kwsinit(&kwset);


BasicTester, a patch instance with id 103:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (beg);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 126
Counter: 127
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
beg = (pat);
kwsinit(&kwset);


BasicTester, a patch instance with id 104:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (pat);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 127
Counter: 128
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
beg = (pattern);
kwsinit(&kwset);


BasicTester, a patch instance with id 105:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (pattern);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 128
Counter: 129
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
beg = lim;
kwsinit(&kwset);


BasicTester, a patch instance with id 106:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = lim;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 129
Counter: 130
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
(lim)++;
kwsinit(&kwset);


BasicTester, a patch instance with id 107:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(lim)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 130
Counter: 131
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
beg = (err);
kwsinit(&kwset);


BasicTester, a patch instance with id 108:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 131
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  //prophet generated patch
  if (__get_mutant()==0) {
  beg = (lim);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==1) {
  beg = pat;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==2) {
  end = (end);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==3) {
  end = (err);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==4) {
  end = (beg);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==5) {
  beg = (pat);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==6) {
  beg = (pattern);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==7) {
  beg = lim;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==8) {
  (lim)++;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==9) {
  beg = (err);
  kwsinit(&kwset);
  }
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 99:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (lim);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 100:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = pat;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 101:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (end);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 102:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 103:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (beg);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 104:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (pat);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 105:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (pattern);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 106:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = lim;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 107:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(lim)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 108:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 132
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
(pattern)++;
kwsinit(&kwset);


BasicTester, a patch instance with id 109:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(pattern)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 132
Counter: 133
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
beg = (end);
kwsinit(&kwset);


BasicTester, a patch instance with id 110:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (end);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 133
Counter: 134
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
(err)++;
kwsinit(&kwset);


BasicTester, a patch instance with id 111:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(err)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 134
Counter: 135
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
beg = (beg);
kwsinit(&kwset);


BasicTester, a patch instance with id 112:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (beg);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 135
Counter: 136
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
(pat)++;
kwsinit(&kwset);


BasicTester, a patch instance with id 113:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(pat)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 136
Counter: 137
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
xalloc_die();
kwsinit(&kwset);


BasicTester, a patch instance with id 114:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
xalloc_die();
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 137
Counter: 138
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
psize = (1);
kwsinit(&kwset);


BasicTester, a patch instance with id 115:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
psize = (1);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 138
Counter: 139
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
psize = (size);
kwsinit(&kwset);


BasicTester, a patch instance with id 116:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
psize = (size);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 139
Counter: 140
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
psize = size;
kwsinit(&kwset);


BasicTester, a patch instance with id 117:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
psize = size;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 140
Counter: 141
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
psize = (psize);
kwsinit(&kwset);


BasicTester, a patch instance with id 118:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
psize = (psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 141
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  //prophet generated patch
  if (__get_mutant()==0) {
  (pattern)++;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==1) {
  beg = (end);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==2) {
  (err)++;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==3) {
  beg = (beg);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==4) {
  (pat)++;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==5) {
  xalloc_die();
  kwsinit(&kwset);
  }
  else if (__get_mutant()==6) {
  psize = (1);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==7) {
  psize = (size);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==8) {
  psize = size;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==9) {
  psize = (psize);
  kwsinit(&kwset);
  }
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 109:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(pattern)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 110:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (end);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 111:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(err)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 112:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
beg = (beg);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 113:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(pat)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 114:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
xalloc_die();
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 115:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
psize = (1);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 116:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
psize = (size);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 117:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
psize = size;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 118:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
psize = (psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 142
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = mbtolower((end), &psize);
kwsinit(&kwset);


BasicTester, a patch instance with id 119:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((end), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 142
Counter: 143
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
psize = (0);
kwsinit(&kwset);


BasicTester, a patch instance with id 120:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
psize = (0);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 143
Counter: 144
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = pattern;
kwsinit(&kwset);


BasicTester, a patch instance with id 121:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = pattern;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 144
Counter: 145
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = mbtolower((pattern), &psize);
kwsinit(&kwset);


BasicTester, a patch instance with id 122:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((pattern), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 145
Counter: 146
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = mbtolower(pattern, &psize);
kwsinit(&kwset);


BasicTester, a patch instance with id 123:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower(pattern, &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 146
Counter: 147
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = mbtolower((err), &psize);
kwsinit(&kwset);


BasicTester, a patch instance with id 124:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((err), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 147
Counter: 148
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = mbtolower((lim), &psize);
kwsinit(&kwset);


BasicTester, a patch instance with id 125:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((lim), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 148
Counter: 149
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = mbtolower((pat), &psize);
kwsinit(&kwset);


BasicTester, a patch instance with id 126:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((pat), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 149
Counter: 150
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = (lim);
kwsinit(&kwset);


BasicTester, a patch instance with id 127:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (lim);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 150
Counter: 151
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = mbtolower((beg), &psize);
kwsinit(&kwset);


BasicTester, a patch instance with id 128:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((beg), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 151
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  //prophet generated patch
  if (__get_mutant()==0) {
  pat = mbtolower((end), &psize);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==1) {
  psize = (0);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==2) {
  pat = pattern;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==3) {
  pat = mbtolower((pattern), &psize);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==4) {
  pat = mbtolower(pattern, &psize);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==5) {
  pat = mbtolower((err), &psize);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==6) {
  pat = mbtolower((lim), &psize);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==7) {
  pat = mbtolower((pat), &psize);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==8) {
  pat = (lim);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==9) {
  pat = mbtolower((beg), &psize);
  kwsinit(&kwset);
  }
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 119:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((end), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 120:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
psize = (0);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 121:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = pattern;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 122:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((pattern), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 123:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower(pattern, &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 124:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((err), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 125:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((lim), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 126:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((pat), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 127:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (lim);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 128:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = mbtolower((beg), &psize);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Counter: 152
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
lim++;
kwsinit(&kwset);


BasicTester, a patch instance with id 129:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
lim++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 152
Counter: 153
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = (beg);
kwsinit(&kwset);


BasicTester, a patch instance with id 130:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (beg);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 153
Counter: 154
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = (pattern);
kwsinit(&kwset);


BasicTester, a patch instance with id 131:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (pattern);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 154
Counter: 155
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = (pat);
kwsinit(&kwset);


BasicTester, a patch instance with id 132:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (pat);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 155
Counter: 156
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = (err);
kwsinit(&kwset);


BasicTester, a patch instance with id 133:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 156
Counter: 157
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
pat = (end);
kwsinit(&kwset);


BasicTester, a patch instance with id 134:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (end);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 157
Counter: 158
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
kwsinit(&kwset);
kwsinit(&kwset);


BasicTester, a patch instance with id 135:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
kwsinit(&kwset);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 158
Counter: 159
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
if (match_icase && (__ctype_get_mb_cur_max()) > 1)
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;
kwsinit(&kwset);


BasicTester, a patch instance with id 136:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
if (match_icase && (__ctype_get_mb_cur_max()) > 1)
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 159
Counter: 160
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
if ((err = kwsincr(kwset, beg, end - beg)) != ((void *)0))
    error(EXIT_TROUBLE, 0, "%s", err);
kwsinit(&kwset);


BasicTester, a patch instance with id 137:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
if ((err = kwsincr(kwset, beg, end - beg)) != ((void *)0))
    error(EXIT_TROUBLE, 0, "%s", err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 160
Counter: 161
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (lim));
kwsinit(&kwset);


BasicTester, a patch instance with id 138:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (lim));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 161
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  //prophet generated patch
  if (__get_mutant()==0) {
  lim++;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==1) {
  pat = (beg);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==2) {
  pat = (pattern);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==3) {
  pat = (pat);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==4) {
  pat = (err);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==5) {
  pat = (end);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==6) {
  kwsinit(&kwset);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==7) {
  if (match_icase && (__ctype_get_mb_cur_max()) > 1)
      pat = mbtolower(pattern, &psize);
  else
      pat = pattern;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==8) {
  if ((err = kwsincr(kwset, beg, end - beg)) != ((void *)0))
      error(EXIT_TROUBLE, 0, "%s", err);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==9) {
  error(EXIT_TROUBLE, 0, "%s", (lim));
  kwsinit(&kwset);
  }
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 129:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
lim++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 130:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (beg);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 131:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (pattern);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 132:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (pat);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 133:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 134:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
pat = (end);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 135:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
kwsinit(&kwset);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 136:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
if (match_icase && (__ctype_get_mb_cur_max()) > 1)
    pat = mbtolower(pattern, &psize);
else
    pat = pattern;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 137:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
if ((err = kwsincr(kwset, beg, end - beg)) != ((void *)0))
    error(EXIT_TROUBLE, 0, "%s", err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 138:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (lim));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Counter: 162
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
if ((err = kwsprep(kwset)) != ((void *)0))
    error(EXIT_TROUBLE, 0, "%s", err);
kwsinit(&kwset);


BasicTester, a patch instance with id 139:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
if ((err = kwsprep(kwset)) != ((void *)0))
    error(EXIT_TROUBLE, 0, "%s", err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 162
Counter: 163
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", err);
kwsinit(&kwset);


BasicTester, a patch instance with id 140:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 163
Counter: 164
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (pattern));
kwsinit(&kwset);


BasicTester, a patch instance with id 141:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (pattern));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 164
Counter: 165
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (pat));
kwsinit(&kwset);


BasicTester, a patch instance with id 142:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (pat));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 165
Counter: 166
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (err));
kwsinit(&kwset);


BasicTester, a patch instance with id 143:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (err));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 166
Counter: 167
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
error((EXIT_TROUBLE), 0, "%s", err);
kwsinit(&kwset);


BasicTester, a patch instance with id 144:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error((EXIT_TROUBLE), 0, "%s", err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 167
Counter: 168
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (end));
kwsinit(&kwset);


BasicTester, a patch instance with id 145:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (end));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 168
Counter: 169
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
(end)++;
kwsinit(&kwset);


BasicTester, a patch instance with id 146:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(end)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 169
Counter: 170
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
end = (lim);
kwsinit(&kwset);


BasicTester, a patch instance with id 147:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (lim);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 170
Counter: 171
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
end = (pat);
kwsinit(&kwset);


BasicTester, a patch instance with id 148:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (pat);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 171
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  //prophet generated patch
  if (__get_mutant()==0) {
  if ((err = kwsprep(kwset)) != ((void *)0))
      error(EXIT_TROUBLE, 0, "%s", err);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==1) {
  error(EXIT_TROUBLE, 0, "%s", err);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==2) {
  error(EXIT_TROUBLE, 0, "%s", (pattern));
  kwsinit(&kwset);
  }
  else if (__get_mutant()==3) {
  error(EXIT_TROUBLE, 0, "%s", (pat));
  kwsinit(&kwset);
  }
  else if (__get_mutant()==4) {
  error(EXIT_TROUBLE, 0, "%s", (err));
  kwsinit(&kwset);
  }
  else if (__get_mutant()==5) {
  error((EXIT_TROUBLE), 0, "%s", err);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==6) {
  error(EXIT_TROUBLE, 0, "%s", (end));
  kwsinit(&kwset);
  }
  else if (__get_mutant()==7) {
  (end)++;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==8) {
  end = (lim);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==9) {
  end = (pat);
  kwsinit(&kwset);
  }
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 139:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
if ((err = kwsprep(kwset)) != ((void *)0))
    error(EXIT_TROUBLE, 0, "%s", err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 140:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 141:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (pattern));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 142:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (pat));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 143:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (err));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 144:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error((EXIT_TROUBLE), 0, "%s", err);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 145:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (end));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 146:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(end)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 147:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (lim);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 148:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (pat);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 172
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
end = (pattern);
kwsinit(&kwset);


BasicTester, a patch instance with id 149:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (pattern);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 172
Counter: 173
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (beg));
kwsinit(&kwset);


BasicTester, a patch instance with id 150:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (beg));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 173
Counter: 174
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 7472
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
end = lim;
kwsinit(&kwset);


BasicTester, a patch instance with id 151:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = lim;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 174
Counter: 175
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 7444
At location src/kwsearch.c:39
--Src File: src/kwsearch.c
Fragment 0:
(beg)++;
kwsinit(&kwset);


BasicTester, a patch instance with id 152:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(beg)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 175
Counter: 176
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 5000
At location src/kwsearch.c:112
--Src File: src/kwsearch.c
Fragment 0:
{
    if (!(__abst_hole(beg, mb_start, s0, buf, size, offset, len, start_ptr, match_words, kwset, match_lines, eol, try, match_icase, eolbyte, ret_val, end, match_size)))
        goto failure;
}


CondTester, a patch instance with id 22:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    
//Patch 0:
{
    if (!(__is_neg(18, &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(offset), sizeof (offset), &(len), sizeof (len), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(kwset), sizeof (kwset), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
        goto failure;
}

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 176
Counter: 177
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (beg) - beg;
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 153:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (beg) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 177
Counter: 178
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (size);
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 154:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (size);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 178
Counter: 179
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = end - (buf);
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 155:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = end - (buf);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 179
Counter: 180
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = end - (mb_start);
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 156:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = end - (mb_start);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 180
Counter: 181
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = end - (s0);
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 157:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = end - (s0);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 181
Counter: 182
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = end - (end);
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 158:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = end - (end);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 182
Counter: 183
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (start_ptr) - beg;
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 159:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (start_ptr) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 183
Counter: 184
Batcher Size:33
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (try) - beg;
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 160:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (try) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 184
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((mb_start == s0) && !(__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      goto failure;
	  }
	  else if (__get_mutant()==1) {
	  if ((mb_start == s0) || (__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	      goto failure;
	  }
	  else if (__get_mutant()==2) {
	  len = (beg) - beg;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==3) {
	  len = (size);
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==4) {
	  len = end - (buf);
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==5) {
	  len = end - (mb_start);
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==6) {
	  len = end - (s0);
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==7) {
	  len = end - (end);
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==8) {
	  len = (start_ptr) - beg;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==9) {
	  len = (try) - beg;
	  if (mb_start == s0)
	      goto failure;
	  }
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 17:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((mb_start == s0) && !(__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 18:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
if ((mb_start == s0) || (__is_neg(18, &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(offset), sizeof (offset), &(len), sizeof (len), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 153:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (beg) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 154:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (size);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 155:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = end - (buf);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 156:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = end - (mb_start);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 157:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = end - (s0);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 158:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = end - (end);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 159:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (start_ptr) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 160:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (try) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Counter: 185
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = end - (beg);
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 161:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = end - (beg);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 185
Counter: 186
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (buf) - beg;
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 162:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (buf) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 186
Counter: 187
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (mb_start) - beg;
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 163:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (mb_start) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 187
Counter: 188
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (ret_val);
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 164:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (ret_val);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 188
Counter: 189
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (s0) - beg;
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 165:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (s0) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 189
Counter: 190
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (offset);
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 166:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (offset);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 190
Counter: 191
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (end) - beg;
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 167:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (end) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 191
Counter: 192
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
len = (len);
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 168:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (len);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 192
Counter: 193
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
end = (try);
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 169:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
end = (try);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 193
Counter: 194
Batcher Size:33
Preprocess the following candidate with BasicTester:
Priority 4999
At location src/kwsearch.c:111
--Src File: src/kwsearch.c
Fragment 0:
error(EXIT_TROUBLE, 0, "%s", (s0));
if (mb_start == s0)
    goto failure;


BasicTester, a patch instance with id 170:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (s0));
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Spawn 1 instances, now Total 194
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  len = end - (beg);
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==1) {
	  len = (buf) - beg;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==2) {
	  len = (mb_start) - beg;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==3) {
	  len = (ret_val);
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==4) {
	  len = (s0) - beg;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==5) {
	  len = (offset);
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==6) {
	  len = (end) - beg;
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==7) {
	  len = (len);
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==8) {
	  end = (try);
	  if (mb_start == s0)
	      goto failure;
	  }
	  else if (__get_mutant()==9) {
	  error(EXIT_TROUBLE, 0, "%s", (s0));
	  if (mb_start == s0)
	      goto failure;
	  }
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 161:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = end - (beg);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 162:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (buf) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 163:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (mb_start) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 164:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (ret_val);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 165:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (s0) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 166:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (offset);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 167:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (end) - beg;
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 168:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
len = (len);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 169:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
end = (try);
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 170:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (s0));
if (mb_start == s0)
    goto failure;

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Passed!
Update best score 4998830.000000
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  //prophet generated patch
  if (__get_mutant()==0) {
  end = (pattern);
  kwsinit(&kwset);
  }
  else if (__get_mutant()==1) {
  error(EXIT_TROUBLE, 0, "%s", (beg));
  kwsinit(&kwset);
  }
  else if (__get_mutant()==2) {
  end = lim;
  kwsinit(&kwset);
  }
  else if (__get_mutant()==3) {
  (beg)++;
  kwsinit(&kwset);
  }
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 149:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = (pattern);
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 150:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
error(EXIT_TROUBLE, 0, "%s", (beg));
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
BasicTester, Testing instance id 151:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
end = lim;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
BasicTester, Testing instance id 152:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  
//Patch 0:
(beg)++;
kwsinit(&kwset);

//CodeSeg 1:
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  if ((match_icase && (__ctype_get_mb_cur_max()) > 1) && !(__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
      pat = mbtolower(pattern, &psize);
  else
      pat = pattern;
  }
  else if (__get_mutant()==1) {
  if ((match_icase && (__ctype_get_mb_cur_max()) > 1) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err))))
      pat = mbtolower(pattern, &psize);
  else
      pat = pattern;
  }
  else if (__get_mutant()==2) {
  if (((match_icase) || (__is_neg(10, &(match_icase), sizeof (match_icase), &(pattern), sizeof (pattern), &(pat), sizeof (pat), &(psize), sizeof (psize), &(size), sizeof (size), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(lim), sizeof (lim), &(end), sizeof (end), &(err), sizeof (err)))) && (__ctype_get_mb_cur_max()) > 1)
      pat = mbtolower(pattern, &psize);
  else
      pat = pattern;
  }

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcSingle building for Tester 0x29dabe0 id 0 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcSingle building for Tester 0x29dabe0 id 5 failed as well!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcSingle building for Tester 0x29dabe0 id 14 failed as well!
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  //prophet generated patch
	  if (__get_mutant()==0) {
	  if ((lim >= pat + psize) && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
	      break;
	  }
	  else if (__get_mutant()==1) {
	  if ((lim >= pat + psize) || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
	      break;
	  }
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 15:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 16:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  
//Patch 0:
if ((lim >= pat + psize) || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size), &(kwset), sizeof (kwset), &(err), sizeof (err))))
    break;

//CodeSeg 1:
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 //prophet generated patch
	 if (__get_mutant()==0) {
	 if ((*lim == '\n') && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
	     lim++;
	     break;
	 }
	 }
	 else if (__get_mutant()==1) {
	 if ((*lim == '\n') || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
	     lim++;
	     break;
	 }
	 }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 6:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') && !(__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 9:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 
//Patch 0:
if ((*lim == '\n') || (__is_neg(10, &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(end), sizeof (end), &(beg), sizeof (beg), &(pattern), sizeof (pattern), &(err), sizeof (err), &(match_icase), sizeof (match_icase), &(kwset), sizeof (kwset), &(size), sizeof (size)))) {
    lim++;
    break;
}

//CodeSeg 1:
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      //prophet generated patch
      if (__get_mutant()==0) {
      if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
          error(EXIT_TROUBLE, 0, "%s", err);
      }
      else if (__get_mutant()==1) {
      if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
          error(EXIT_TROUBLE, 0, "%s", err);
      }
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 7:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) && !(__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 8:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Postprocessing instance id 8:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      
//Patch 0:
if (((err = kwsincr(kwset, beg, end - beg)) != ((void *)0)) || (__is_neg(10, &(beg), sizeof (beg), &(end), sizeof (end), &(err), sizeof (err), &(kwset), sizeof (kwset), &(lim), sizeof (lim), &(pat), sizeof (pat), &(psize), sizeof (psize), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr err == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize == 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Passed!
Passed with updated best score 19999992.000000
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  //prophet generated patch
  if (__get_mutant()==0) {
  if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
      error(EXIT_TROUBLE, 0, "%s", err);
  }
  else if (__get_mutant()==1) {
  if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
      error(EXIT_TROUBLE, 0, "%s", err);
  }
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 1:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) && !(__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 2:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed!
CondTester, Postprocessing instance id 2:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  
//Patch 0:
if (((err = kwsprep(kwset)) != ((void *)0)) || (__is_neg(10, &(err), sizeof (err), &(kwset), sizeof (kwset), &(beg), sizeof (beg), &(pat), sizeof (pat), &(psize), sizeof (psize), &(lim), sizeof (lim), &(end), sizeof (end), &(pattern), sizeof (pattern), &(match_icase), sizeof (match_icase), &(size), sizeof (size))))
    error(EXIT_TROUBLE, 0, "%s", err);

//CodeSeg 1:
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr err == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr size != 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr psize == 1
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 20  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 25  > __res
Passed Positive Cases
Passed!
Passed with updated best score 19999998.000000
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  //prophet generated patch
  if (__get_mutant()==0) {
  (start_ptr)++;
  if ((__ctype_get_mb_cur_max()) > 1) {
      if (match_icase) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
  }
  }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 98:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  
//Patch 0:
(start_ptr)++;
if ((__ctype_get_mb_cur_max()) > 1) {
    if (match_icase) {
        char *case_buf = mbtolower(buf, &size);
        if (start_ptr)
            start_ptr = case_buf + (start_ptr - buf);
        buf = case_buf;
    }
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 9  > __res
Failed positive case 9
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((match_icase) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
      else if (__get_mutant()==1) {
      if ((match_icase) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          char *case_buf = mbtolower(buf, &size);
          if (start_ptr)
              start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
      }
      }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 10:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) && !(__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 11:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      
//Patch 0:
if ((match_icase) || (__is_neg(16, &(match_icase), sizeof (match_icase), &(buf), sizeof (buf), &(size), sizeof (size), &(start_ptr), sizeof (start_ptr), &(eolbyte), sizeof (eolbyte), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(kwset), sizeof (kwset), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    char *case_buf = mbtolower(buf, &size);
    if (start_ptr)
        start_ptr = case_buf + (start_ptr - buf);
    buf = case_buf;
}

//CodeSeg 1:
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((offset == (size_t)-1) && !(__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          goto failure;
      }
      else if (__get_mutant()==1) {
      if ((offset == (size_t)-1) || (__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
          goto failure;
      }
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 3:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) && !(__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 4:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      
//Patch 0:
if ((offset == (size_t)-1) || (__is_neg(18, &(offset), sizeof (offset), &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(mb_start), sizeof (mb_start), &(len), sizeof (len), &(match_icase), sizeof (match_icase), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(eolbyte), sizeof (eolbyte), &(try), sizeof (try), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size), &(kwsmatch.index), sizeof (kwsmatch.index))))
    goto failure;

//CodeSeg 1:
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    goto failure;
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      //prophet generated patch
      if (__get_mutant()==0) {
      if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          if (mb_start == s0)
              goto failure;
          beg = mb_start - 1;
          continue;
      }
      }
      else if (__get_mutant()==1) {
      if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
          if (mb_start == s0)
              goto failure;
          beg = mb_start - 1;
          continue;
      }
      }
      else if (__get_mutant()==2) {
      if ((((__ctype_get_mb_cur_max()) > 1) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
          if (mb_start == s0)
              goto failure;
          beg = mb_start - 1;
          continue;
      }
      }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 19:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) && !(__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 20:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if (((__ctype_get_mb_cur_max()) > 1 && is_mb_middle(&mb_start, beg + offset, buf + size)) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
CondTester, Testing instance id 21:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      
//Patch 0:
if ((((__ctype_get_mb_cur_max()) > 1) || (__is_neg(18, &(buf), sizeof (buf), &(size), sizeof (size), &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(offset), sizeof (offset), &(s0), sizeof (s0), &(kwset), sizeof (kwset), &(start_ptr), sizeof (start_ptr), &(len), sizeof (len), &(match_words), sizeof (match_words), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(match_icase), sizeof (match_icase), &(try), sizeof (try), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size)))) && is_mb_middle(&mb_start, beg + offset, buf + size)) {
    if (mb_start == s0)
        goto failure;
    beg = mb_start - 1;
    continue;
}

//CodeSeg 1:
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/kwsearch.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    //prophet generated patch
	    if (__get_mutant()==0) {
	    {
	        if (!(__is_neg(18, &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(offset), sizeof (offset), &(len), sizeof (len), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(kwset), sizeof (kwset), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
	            goto failure;
	    }
	    }
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 22:
//src_file:src/kwsearch.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); void* memset(void*, int, unsigned long); 
/* kwsearch.c - searching subroutines using kwset for grep.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written August 1992 by Mike Haertel. */

#include <config.h>
#include "search.h"

/* For -w, we also consider _ to be word constituent.  */
#define WCHAR(C) (ISALNUM(C) || (C) == '_')

/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   a list of strings, at least one of which is known to occur in
   any string matching the regexp. */
static kwset_t kwset;

void
Fcompile (char const *pattern, size_t size)
{
  char const *beg, *end, *lim, *err, *pat;
  size_t psize;

  kwsinit (&kwset);
  psize = size;
#ifdef MBS_SUPPORT
  if (match_icase && MB_CUR_MAX > 1)
    pat = mbtolower (pattern, &psize);
  else
#endif
    pat = pattern;

  beg = pat;
  do
    {
      for (lim = beg;; ++lim)
	{
	  end = lim;
	  if (lim >= pat + psize)
	    break;
	 if (*lim == '\n')
	   {
	     lim++;
	     break;
	   }
#if HAVE_DOS_FILE_CONTENTS
	 if (*lim == '\r' && lim + 1 < pat + psize && lim[1] == '\n')
	   {
	     lim += 2;
	     break;
	   }
#endif
	}

      if ((err = kwsincr (kwset, beg, end - beg)) != NULL)
	error (EXIT_TROUBLE, 0, "%s", err);
      beg = lim;
    }
  while (beg < pat + psize);

  if ((err = kwsprep (kwset)) != NULL)
    error (EXIT_TROUBLE, 0, "%s", err);
}

size_t
Fexecute (char const *buf, size_t size, size_t *match_size,
	  char const *start_ptr)
{
  char const *beg, *try, *end, *mb_start;
  size_t len;
  char eol = eolbyte;
  struct kwsmatch kwsmatch;
  size_t ret_val;
#ifdef MBS_SUPPORT
  if (MB_CUR_MAX > 1)
    {
      if (match_icase)
        {
          char *case_buf = mbtolower (buf, &size);
	  if (start_ptr)
	    start_ptr = case_buf + (start_ptr - buf);
          buf = case_buf;
        }
    }
#endif /* MBS_SUPPORT */

  for (mb_start = beg = start_ptr ? start_ptr : buf; beg <= buf + size; beg++)
    {
      size_t offset = kwsexec (kwset, beg, buf + size - beg, &kwsmatch);
      if (offset == (size_t) -1)
	goto failure;
#ifdef MBS_SUPPORT
      char const *s0 = mb_start;
      if (MB_CUR_MAX > 1 && is_mb_middle (&mb_start, beg + offset, buf + size))
        {
	  if (mb_start == s0)
	    
//Patch 0:
{
    if (!(__is_neg(18, &(beg), sizeof (beg), &(mb_start), sizeof (mb_start), &(s0), sizeof (s0), &(buf), sizeof (buf), &(size), sizeof (size), &(offset), sizeof (offset), &(len), sizeof (len), &(start_ptr), sizeof (start_ptr), &(match_words), sizeof (match_words), &(kwset), sizeof (kwset), &(match_lines), sizeof (match_lines), &(eol), sizeof (eol), &(try), sizeof (try), &(match_icase), sizeof (match_icase), &(eolbyte), sizeof (eolbyte), &(ret_val), sizeof (ret_val), &(end), sizeof (end), &(match_size), sizeof (match_size))))
        goto failure;
}

//CodeSeg 1:
          beg = mb_start - 1;
          continue; /* It is a part of multibyte character.  */
        }
#endif /* MBS_SUPPORT */
      beg += offset;
      len = kwsmatch.size[0];
      if (start_ptr && !match_words)
	goto success_in_beg_and_len;
      if (match_lines)
	{
	  if (beg > buf && beg[-1] != eol)
	    continue;
	  if (beg + len < buf + size && beg[len] != eol)
	    continue;
	  goto success;
	}
      else if (match_words)
	for (try = beg; len; )
	  {
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
	      {
		offset = kwsexec (kwset, beg, --len, &kwsmatch);
		if (offset == (size_t) -1)
		  break;
		try = beg + offset;
		len = kwsmatch.size[0];
	      }
	    else if (!start_ptr)
	      goto success;
	    else
	      goto success_in_beg_and_len;
	  } /* for (try) */
      else
	goto success;
    } /* for (beg in buf) */

 failure:
  ret_val = -1;
  goto out;

 success:
  if ((end = memchr (beg + len, eol, (buf + size) - (beg + len))) != NULL)
    end++;
  else
    end = buf + size;
  while (buf < beg && beg[-1] != eol)
    --beg;
  len = end - beg;
 success_in_beg_and_len:
  *match_size = len;
  ret_val = beg - buf;
 out:
  return ret_val;
}

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 0
Iteration 2
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/neg.tmp!
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-db9d6340-6d952bee/tempworkdir 0  > __res
Total cnt of passed cond schemas: 2
Total cnt of cond schemas: 23
Counter: 195
Batcher Size:0
The found score 19999998.000000 is greater than current score 4999.000000!
Terminate current session!
Generated a patch at candidate schema no 3
Total cnt of passed cond schemas: 2
Total cnt of cond schemas: 23
Candidate count:0!!
Found a fix! Store to: grep-fix-db9d6340-6d952beesrc_kwsearch.c
Found a fix! Store to: grep-fix-db9d6340-6d952beesrc_kwsearch.c-1
Found a fix! Store to: grep-fix-db9d6340-6d952beesrc_kwsearch.c-2
Repair process ends successfully!
Total 2354 different repair candidate schema!!!!
Total number of compiles: 41
Total number of test eval: 400
