Initialize the program!
Verify Test Cases
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcRunning test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 3 4 5 6 9 13 14 15 17 18 22 23 25  > __res
All passed!
Done Verification
Generating repair candidates!
Processing src/searchutils.c
In dir /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src
Total 368 different repair candidate templates!!!!
Total 368 different repair candidate templates!!!!
Total 516 different repair candidate!!!
Trying different candidates!
BasicTester pointer: 0x24ae6e0
CondTester pointer: 0x2543e10
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) && !(__abst_hole(match_icase, i, kwset))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


CondTester, a patch instance with id 0:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) && !(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
if ((!*kwset) && !(__abst_hole(kwset, i, match_icase)))
    xalloc_die();


CondTester, a patch instance with id 1:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if ((!*kwset) && !(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
if ((!*kwset) || (__abst_hole(kwset, i, match_icase)))
    xalloc_die();


CondTester, a patch instance with id 2:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if ((!*kwset) || (__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) || (__abst_hole(match_icase, i, kwset))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


CondTester, a patch instance with id 3:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
if (((match_icase) || (__abst_hole(match_icase, i, kwset))) && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


CondTester, a patch instance with id 4:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (((match_icase) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
if ((p > buf || match_len < mbrlen(p, end - p, &cur_state)) && !(__abst_hole(buf, end, match_len, p, good, prev)))
    return 1;


CondTester, a patch instance with id 5:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
if ((p > buf || match_len < mbrlen(p, end - p, &cur_state)) && !(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
if ((p > buf || match_len < mbrlen(p, end - p, &cur_state)) || (__abst_hole(buf, end, match_len, p, good, prev)))
    return 1;


CondTester, a patch instance with id 6:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
if ((p > buf || match_len < mbrlen(p, end - p, &cur_state)) || (__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
if ((mbclen != (size_t)-2) && !(__abst_hole(mbclen, p, prev, end, buf, good, match_len)))
    prev = p;


CondTester, a patch instance with id 7:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if ((mbclen != (size_t)-2) && !(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
if ((mbclen != (size_t)-2) || (__abst_hole(mbclen, p, prev, end, buf, good, match_len)))
    prev = p;


CondTester, a patch instance with id 8:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if ((mbclen != (size_t)-2) || (__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) && !(__abst_hole(mbclen, p, prev, end, buf, good, match_len))) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


CondTester, a patch instance with id 9:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) && !(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len)))) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) || (__abst_hole(mbclen, p, prev, end, buf, good, match_len))) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


CondTester, a patch instance with id 10:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) || (__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len)))) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 0:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 1:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
xalloc_die();
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof cur_state);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 2:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
prev = (end);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 3:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (end);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
prev = (prev);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 4:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (prev);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
prev = p;
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 5:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = p;
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
prev = (p);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 6:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (p);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof(mbstate_t));
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 7:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
prev = (buf);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 8:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (buf);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 9:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
*good = (end);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 21
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==1) {
  xalloc_die();
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==2) {
  memset(&cur_state, 0, sizeof cur_state);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==3) {
  prev = (end);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==4) {
  prev = (prev);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==5) {
  prev = p;
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==6) {
  prev = (p);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==7) {
  memset(&cur_state, 0, sizeof(mbstate_t));
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==8) {
  prev = (buf);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==9) {
  *good = (end);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 0:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 1:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
xalloc_die();
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 2:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 3:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (end);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 4:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (prev);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 5:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = p;
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 6:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (p);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 7:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 8:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
prev = (buf);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 9:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
*good = (end);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 22
Batcher Size:11
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
*good = (p);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 10:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
*good = (p);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:12
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 11:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
*good = (prev);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:13
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
*good = prev;
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 12:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
*good = prev;
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:14
Preprocess the following candidate with BasicTester:
Priority 7500
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 13:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
*good = (buf);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (0);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 14:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (0);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
if (!*kwset)
    xalloc_die();
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 15:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (!*kwset)
    xalloc_die();
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (-128);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 16:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (-128);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
    int __res;
    if (sizeof (i) > 1) {
        if (__builtin_constant_p(i)) {
            int __c = (i);
            __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
        } else
            __res = tolower(i);
    } else
        __res = (*__ctype_tolower_loc())[(int)(i)];
    __res;
})) : (i));
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 17:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
    int __res;
    if (sizeof (i) > 1) {
        if (__builtin_constant_p(i)) {
            int __c = (i);
            __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
        } else
            __res = tolower(i);
    } else
        __res = (*__ctype_tolower_loc())[(int)(i)];
    __res;
})) : (i));
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 18:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
xalloc_die();
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (256);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 19:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (256);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (255);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 20:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (255);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 32
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  //prophet generated patch
  if (__get_mutant()==0) {
  if ((match_icase && (__ctype_get_mb_cur_max()) == 1) && !(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==1) {
  if ((match_icase && (__ctype_get_mb_cur_max()) == 1) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==2) {
  if (((match_icase) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==3) {
  trans[i] = (0);
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==4) {
  if (!*kwset)
      xalloc_die();
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==5) {
  trans[i] = (-128);
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==6) {
  trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
      int __res;
      if (sizeof (i) > 1) {
          if (__builtin_constant_p(i)) {
              int __c = (i);
              __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
          } else
              __res = tolower(i);
      } else
          __res = (*__ctype_tolower_loc())[(int)(i)];
      __res;
  })) : (i));
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==7) {
  xalloc_die();
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==8) {
  trans[i] = (256);
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==9) {
  trans[i] = (255);
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) && !(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 3:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if ((match_icase && (__ctype_get_mb_cur_max()) == 1) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 4:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (((match_icase) || (__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset)))) && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 14:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (0);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 15:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (!*kwset)
    xalloc_die();
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 16:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (-128);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 17:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
    int __res;
    if (sizeof (i) > 1) {
        if (__builtin_constant_p(i)) {
            int __c = (i);
            __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
        } else
            __res = tolower(i);
    } else
        __res = (*__ctype_tolower_loc())[(int)(i)];
    __res;
})) : (i));
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 18:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
xalloc_die();
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 19:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (256);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 20:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (255);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 33
Batcher Size:12
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
*kwset = kwsalloc(trans);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 21:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
*kwset = kwsalloc(trans);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:13
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (254);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 22:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (254);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:14
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (1);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 23:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (1);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (127);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 24:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (127);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (2);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 25:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (2);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 7325
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (128);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 26:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (128);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 7151
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
*kwset = kwsalloc(((void *)0));
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


BasicTester, a patch instance with id 27:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
*kwset = kwsalloc(((void *)0));
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memmove(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 28:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memmove(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 29:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memcmp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 30:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memcmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memmove(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 31:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memmove(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
execle(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 32:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
execle(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memcpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 33:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 45
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  *good = (p);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==1) {
  *good = (prev);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==2) {
  *good = prev;
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==3) {
  *good = (buf);
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==4) {
  memmove(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==5) {
  memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==6) {
  memcmp(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==7) {
  memmove(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==8) {
  execle(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==9) {
  memcpy(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 10:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
*good = (p);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 11:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
*good = (prev);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 12:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
*good = prev;
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 13:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
*good = (buf);
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 28:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memmove(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 29:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 30:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memcmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 31:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memmove(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 32:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
execle(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 33:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 46
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memcpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 34:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
execl(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 35:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
execl(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
open(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 36:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
open(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
open64(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 37:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
open64(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
sscanf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 38:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
sscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 50
Counter: 51
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
obstack_printf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 39:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
obstack_printf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
fscanf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 40:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
scanf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 41:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
scanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
sscanf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 42:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
sscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
scanf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 43:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
scanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 55
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  memcpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==1) {
  execl(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==2) {
  open(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==3) {
  open64(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==4) {
  sscanf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==5) {
  obstack_printf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==6) {
  fscanf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==7) {
  scanf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==8) {
  sscanf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==9) {
  scanf(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 34:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 35:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
execl(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 36:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
open(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 37:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
open64(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 38:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
sscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 39:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
obstack_printf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 40:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 41:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
scanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 42:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
sscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 43:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
scanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 56
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
setbuffer(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 44:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
setbuffer(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
printf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 45:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
printf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
sprintf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 46:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
sprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
fscanf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 47:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
sprintf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 48:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
sprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 60
Counter: 61
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
fprintf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 49:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
fprintf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 50:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
printf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 51:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
printf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 63
Counter: 64
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
fwprintf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 52:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fwprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 64
Counter: 65
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
swscanf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 53:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
swscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 65
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  setbuffer(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==1) {
  printf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==2) {
  sprintf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==3) {
  fscanf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==4) {
  sprintf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==5) {
  fprintf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==6) {
  fprintf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==7) {
  printf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==8) {
  fwprintf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==9) {
  swscanf(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 44:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
setbuffer(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 45:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
printf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 46:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
sprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 47:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 48:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
sprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 49:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 50:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 51:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
printf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 52:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fwprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 53:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
swscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 66
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
execlp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 54:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
execlp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 66
Counter: 67
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
_IO_sgetn(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 55:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
_IO_sgetn(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 67
Counter: 68
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
readlink(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 56:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
readlink(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 68
Counter: 69
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wprintf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 57:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 69
Counter: 70
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
fwscanf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 58:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fwscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 70
Counter: 71
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wscanf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 59:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 71
Counter: 72
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wmempcpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 60:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmempcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 72
Counter: 73
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wcpncpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 61:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcpncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 73
Counter: 74
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wmemset(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 62:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmemset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 74
Counter: 75
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wmemmove(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 63:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmemmove(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 75
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  execlp(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==1) {
  _IO_sgetn(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==2) {
  readlink(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==3) {
  wprintf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==4) {
  fwscanf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==5) {
  wscanf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==6) {
  wmempcpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==7) {
  wcpncpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==8) {
  wmemset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==9) {
  wmemmove(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 54:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
execlp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 55:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
_IO_sgetn(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 56:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
readlink(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 57:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 58:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
fwscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 59:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wscanf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 60:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmempcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 61:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcpncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 62:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmemset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 63:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmemmove(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 76
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wcsxfrm(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 64:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcsxfrm(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 76
Counter: 77
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wmemcmp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 65:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmemcmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 77
Counter: 78
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wmemcpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 66:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmemcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 78
Counter: 79
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wmemchr(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 67:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmemchr(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 79
Counter: 80
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wcsncmp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 68:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcsncmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 80
Counter: 81
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wcsncasecmp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 69:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcsncasecmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 81
Counter: 82
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wcsncpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 70:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcsncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 82
Counter: 83
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wcsncat(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 71:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcsncat(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 83
Counter: 84
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
wcstombs(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 72:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcstombs(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 84
Counter: 85
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
mbstowcs(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 73:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
mbstowcs(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 85
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  wcsxfrm(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==1) {
  wmemcmp(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==2) {
  wmemcpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==3) {
  wmemchr(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==4) {
  wcsncmp(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==5) {
  wcsncasecmp(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==6) {
  wcsncpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==7) {
  wcsncat(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==8) {
  wcstombs(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==9) {
  mbstowcs(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 64:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcsxfrm(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 65:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmemcmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 66:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmemcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 67:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wmemchr(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 68:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcsncmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 69:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcsncasecmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 70:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcsncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 71:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcsncat(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 72:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
wcstombs(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 73:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
mbstowcs(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 86
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
mbtowc(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 74:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
mbtowc(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 86
Counter: 87
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
asprintf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 75:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
asprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 87
Counter: 88
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
__asprintf(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 76:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
__asprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 88
Counter: 89
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
posix_memalign(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 77:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
posix_memalign(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 89
Counter: 90
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
x2nrealloc(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 78:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
x2nrealloc(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 90
Counter: 91
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(buf, p, end, good, prev, match_len)))
    memset(&cur_state, 0, sizeof(mbstate_t));


CondTester, a patch instance with id 11:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
if (!(__is_neg(6, &(buf), sizeof (buf), &(p), sizeof (p), &(end), sizeof (end), &(good), sizeof (good), &(prev), sizeof (prev), &(match_len), sizeof (match_len))))
    memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 91
Counter: 92
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
GEAcompile(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 79:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
GEAcompile(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 92
Counter: 93
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
strncasecmp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 80:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncasecmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 93
Counter: 94
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
stpncpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 81:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
stpncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 94
Counter: 95
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
kwsincr(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 82:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
kwsincr(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 95
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  mbtowc(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==1) {
  asprintf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==2) {
  __asprintf(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==3) {
  posix_memalign(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==4) {
  x2nrealloc(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==5) {
  if (!(__is_neg(6, &(buf), sizeof (buf), &(p), sizeof (p), &(end), sizeof (end), &(good), sizeof (good), &(prev), sizeof (prev), &(match_len), sizeof (match_len))))
      memset(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==6) {
  GEAcompile(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==7) {
  strncasecmp(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==8) {
  stpncpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==9) {
  kwsincr(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 74:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
mbtowc(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 75:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
asprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 76:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
__asprintf(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 77:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
posix_memalign(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 78:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
x2nrealloc(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
CondTester, Testing instance id 11:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
if (!(__is_neg(6, &(buf), sizeof (buf), &(p), sizeof (p), &(end), sizeof (end), &(good), sizeof (good), &(prev), sizeof (prev), &(match_len), sizeof (match_len))))
    memset(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 79:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
GEAcompile(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 80:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncasecmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 81:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
stpncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 82:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
kwsincr(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 96
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
xnrealloc(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 83:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
xnrealloc(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 96
Counter: 97
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
ngettext(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 84:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
ngettext(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 97
Counter: 98
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
strncasecmp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 85:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncasecmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 98
Counter: 99
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
__stpncpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 86:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
__stpncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 99
Counter: 100
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
stpncpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 87:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
stpncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 100
Counter: 101
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
strncmp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 88:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 101
Counter: 102
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
bcmp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 89:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
bcmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 102
Counter: 103
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
__mempcpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 90:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
__mempcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 103
Counter: 104
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
bcopy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 91:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
bcopy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 104
Counter: 105
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
mempcpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 92:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
mempcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 105
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  xnrealloc(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==1) {
  ngettext(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==2) {
  strncasecmp(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==3) {
  __stpncpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==4) {
  stpncpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==5) {
  strncmp(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==6) {
  bcmp(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==7) {
  __mempcpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==8) {
  bcopy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==9) {
  mempcpy(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 83:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
xnrealloc(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 84:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
ngettext(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 85:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncasecmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 86:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
__stpncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 87:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
stpncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 88:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 89:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
bcmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 90:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
__mempcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 91:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
bcopy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 92:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
mempcpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 106
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
strncmp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 93:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 106
Counter: 107
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
strxfrm(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 94:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strxfrm(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 107
Counter: 108
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
strxfrm(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 95:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strxfrm(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 108
Counter: 109
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
strncpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 96:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 109
Counter: 110
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
strncat(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 97:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncat(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 110
Counter: 111
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
strncat(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 98:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncat(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 111
Counter: 112
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
strncpy(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 99:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 112
Counter: 113
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memchr(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 100:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memchr(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 113
Counter: 114
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memrchr(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 101:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memrchr(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 114
Counter: 115
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memcmp(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 102:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memcmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 115
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  strncmp(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==1) {
  strxfrm(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==2) {
  strxfrm(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==3) {
  strncpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==4) {
  strncat(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==5) {
  strncat(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==6) {
  strncpy(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==7) {
  memchr(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==8) {
  memrchr(&cur_state, 0, sizeof(mbstate_t));
  }
  else if (__get_mutant()==9) {
  memcmp(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 93:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 94:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strxfrm(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 95:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strxfrm(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 96:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 97:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncat(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 98:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncat(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 99:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
strncpy(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 100:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memchr(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 101:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memrchr(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 102:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memcmp(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 116
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 5000
At location src/searchutils.c:126
--Src File: src/searchutils.c
Fragment 0:
memchr(&cur_state, 0, sizeof(mbstate_t));


BasicTester, a patch instance with id 103:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memchr(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 116
Counter: 117
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 4988
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    if (!(__abst_hole(buf, end, match_len, p, good, prev)))
        return 1;
}


CondTester, a patch instance with id 12:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    if (!(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
        return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 117
Counter: 118
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 4987
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(buf, end, match_len, p, good, prev)) && (p > buf || match_len < mbrlen(p, end - p, &cur_state)))
    return 1;


CondTester, a patch instance with id 13:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
if (!(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))) && (p > buf || match_len < mbrlen(p, end - p, &cur_state)))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 118
Counter: 119
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 4987
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(buf, end, match_len, p, good, prev)))
    if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
        return 1;


CondTester, a patch instance with id 14:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
if (!(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
    if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
        return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 119
Counter: 120
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 4986
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(good, prev, buf, end, match_len, p)))
    *good = prev;


CondTester, a patch instance with id 15:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
if (!(__is_neg(6, &(good), sizeof (good), &(prev), sizeof (prev), &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p))))
    *good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 120
Counter: 121
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 4985
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
if ((__abst_hole(p, mbclen, good, prev, buf, end, match_len)))
    break;
p += mbclen;


CondTester, a patch instance with id 16:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
if ((__is_neg(7, &(p), sizeof (p), &(mbclen), sizeof (mbclen), &(good), sizeof (good), &(prev), sizeof (prev), &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len))))
    break;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 121
Counter: 122
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 4985
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(p, mbclen, good, prev, buf, end, match_len)))
    p += mbclen;


CondTester, a patch instance with id 17:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
if (!(__is_neg(7, &(p), sizeof (p), &(mbclen), sizeof (mbclen), &(good), sizeof (good), &(prev), sizeof (prev), &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len))))
    p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 122
Counter: 123
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 4984
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(mbclen, p, prev, end, buf, good, match_len)))
    if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
        mbclen = 1;
        memset(&cur_state, 0, sizeof cur_state);
    }


CondTester, a patch instance with id 18:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if (!(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
    if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
        mbclen = 1;
        memset(&cur_state, 0, sizeof cur_state);
    }

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 123
Counter: 124
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 4984
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(mbclen, p, prev, end, buf, good, match_len)) && (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0)) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


CondTester, a patch instance with id 19:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if (!(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))) && (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0)) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 124
Counter: 125
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 4983
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    if (!(__abst_hole(p, prev, mbclen, end, buf, good, match_len)))
        prev = p;
}


CondTester, a patch instance with id 20:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    if (!(__is_neg(7, &(p), sizeof (p), &(prev), sizeof (prev), &(mbclen), sizeof (mbclen), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
        prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 125
Counter: 126
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 104:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
xalloc_die();
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 126
Counter: 127
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
prev = (prev);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 105:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
prev = (prev);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 127
Counter: 128
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
prev = p;
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 106:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
prev = p;
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 128
Counter: 129
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
prev = (end);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 107:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
prev = (end);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 129
Counter: 130
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
prev = (p);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 108:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
prev = (p);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 130
Counter: 131
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof(mbstate_t));
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 109:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 131
Counter: 132
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
prev = (buf);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 110:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
prev = (buf);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 132
Counter: 133
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof cur_state);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 111:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 133
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((mbclen != (size_t)-2) && !(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
          prev = p;
      }
      else if (__get_mutant()==1) {
      if ((mbclen != (size_t)-2) || (__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
          prev = p;
      }
      else if (__get_mutant()==2) {
      xalloc_die();
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==3) {
      prev = (prev);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==4) {
      prev = p;
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==5) {
      prev = (end);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==6) {
      prev = (p);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==7) {
      memset(&cur_state, 0, sizeof(mbstate_t));
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==8) {
      prev = (buf);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==9) {
      memset(&cur_state, 0, sizeof cur_state);
      if (mbclen != (size_t)-2)
          prev = p;
      }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 7:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if ((mbclen != (size_t)-2) && !(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 8:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if ((mbclen != (size_t)-2) || (__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 104:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
xalloc_die();
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 105:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
prev = (prev);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 106:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
prev = p;
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 107:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
prev = (end);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 108:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
prev = (p);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 109:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 110:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
prev = (buf);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 111:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 134
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
mbclen = 1;
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 112:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = 1;
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 134
Counter: 135
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
mbclen = (match_len);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 113:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (match_len);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 135
Counter: 136
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
mbclen = (mbclen);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 114:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (mbclen);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 136
Counter: 137
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
mbclen = (-2);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 115:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (-2);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 137
Counter: 138
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
mbclen = (1);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 116:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (1);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 138
Counter: 139
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
mbclen = (2);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 117:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (2);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 139
Counter: 140
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
mbclen = (0);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 118:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (0);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 140
Counter: 141
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
mbclen = (-1);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 119:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (-1);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 141
Counter: 142
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 120:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 142
Counter: 143
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
if (mbclen != (size_t)-2)
    prev = p;
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 121:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if (mbclen != (size_t)-2)
    prev = p;
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 143
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      //prophet generated patch
      if (__get_mutant()==0) {
      mbclen = 1;
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==1) {
      mbclen = (match_len);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==2) {
      mbclen = (mbclen);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==3) {
      mbclen = (-2);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==4) {
      mbclen = (1);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==5) {
      mbclen = (2);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==6) {
      mbclen = (0);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==7) {
      mbclen = (-1);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==8) {
      if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
          return 1;
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==9) {
      if (mbclen != (size_t)-2)
          prev = p;
      if (mbclen != (size_t)-2)
          prev = p;
      }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 112:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = 1;
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 113:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (match_len);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 114:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (mbclen);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 115:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (-2);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 116:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (1);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 117:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (2);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 118:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (0);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 119:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
mbclen = (-1);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 120:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 121:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if (mbclen != (size_t)-2)
    prev = p;
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 144
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 122:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 144
Counter: 145
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 123:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
*good = (prev);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 145
Counter: 146
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
*good = prev;
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 124:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
*good = prev;
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 146
Counter: 147
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 125:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
*good = (end);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 147
Counter: 148
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
*good = (p);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 126:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
*good = (p);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 148
Counter: 149
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
if (mbclen != (size_t)-2)
    prev = p;


BasicTester, a patch instance with id 127:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
*good = (buf);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 149
Counter: 150
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 4982
At location src/searchutils.c:132
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(mbclen, p, prev, end, buf, good, match_len)))
    if (mbclen != (size_t)-2)
        prev = p;


CondTester, a patch instance with id 21:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if (!(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
    if (mbclen != (size_t)-2)
        prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 150
Counter: 151
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 4980
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(buf, p, end, good, prev, match_len)))
    while (p < buf)
        {
            size_t mbclen = mbrlen(p, end - p, &cur_state);
            if (mbclen != (size_t)-2)
                prev = p;
            if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
                mbclen = 1;
                memset(&cur_state, 0, sizeof cur_state);
            }
            p += mbclen;
        }


CondTester, a patch instance with id 22:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
if (!(__is_neg(6, &(buf), sizeof (buf), &(p), sizeof (p), &(end), sizeof (end), &(good), sizeof (good), &(prev), sizeof (prev), &(match_len), sizeof (match_len))))
    while (p < buf)
        {
            size_t mbclen = mbrlen(p, end - p, &cur_state);
            if (mbclen != (size_t)-2)
                prev = p;
            if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
                mbclen = 1;
                memset(&cur_state, 0, sizeof cur_state);
            }
            p += mbclen;
        }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 151
Counter: 152
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 4861
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(kwset, i, match_icase)) && (!*kwset))
    xalloc_die();


CondTester, a patch instance with id 23:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if (!(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))) && (!*kwset))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 152
Counter: 153
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 4861
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(kwset, i, match_icase)))
    if (!*kwset)
        xalloc_die();


CondTester, a patch instance with id 24:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if (!(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    if (!*kwset)
        xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 153
Counter: 154
Batcher Size:33
Preprocess the following candidate with CondTester:
Priority 4826
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    if (!(__abst_hole(kwset, i, match_icase)))
        *kwset = kwsalloc(((void *)0));
}


CondTester, a patch instance with id 25:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    if (!(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
        *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 154
Counter: 155
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 4825
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(match_icase, i, kwset)) && (match_icase && (__ctype_get_mb_cur_max()) == 1)) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));


CondTester, a patch instance with id 26:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (!(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset))) && (match_icase && (__ctype_get_mb_cur_max()) == 1)) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 155
Counter: 156
Batcher Size:35
Preprocess the following candidate with CondTester:
Priority 4825
At location src/searchutils.c:31
--Src File: src/searchutils.c
Fragment 0:
if (!(__abst_hole(match_icase, i, kwset)))
    if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
        for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
            trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
                int __res;
                if (sizeof (i) > 1) {
                    if (__builtin_constant_p(i)) {
                        int __c = (i);
                        __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                    } else
                        __res = tolower(i);
                } else
                    __res = (*__ctype_tolower_loc())[(int)(i)];
                __res;
            })) : (i));
        *kwset = kwsalloc(trans);
    } else
        *kwset = kwsalloc(((void *)0));


CondTester, a patch instance with id 27:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (!(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset))))
    if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
        for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
            trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
                int __res;
                if (sizeof (i) > 1) {
                    if (__builtin_constant_p(i)) {
                        int __c = (i);
                        __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                    } else
                        __res = tolower(i);
                } else
                    __res = (*__ctype_tolower_loc())[(int)(i)];
                __res;
            })) : (i));
        *kwset = kwsalloc(trans);
    } else
        *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 156
Counter: 157
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority 2486
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);


BasicTester, a patch instance with id 128:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (prev);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 157
Counter: 158
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority 2486
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);


BasicTester, a patch instance with id 129:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (prev);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 158
Counter: 159
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority 2486
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (p);


BasicTester, a patch instance with id 130:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (p);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 159
Counter: 160
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority 2486
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (end);


BasicTester, a patch instance with id 131:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (end);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 160
Counter: 161
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 2486
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);


BasicTester, a patch instance with id 132:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (buf);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 161
Counter: 162
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority 2486
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (p);


BasicTester, a patch instance with id 133:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (p);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 162
Counter: 163
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority 2486
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (end);


BasicTester, a patch instance with id 134:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (end);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 163
Counter: 164
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 2486
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);


BasicTester, a patch instance with id 135:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (buf);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 164
Counter: 165
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 2485
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
p += mbclen;


BasicTester, a patch instance with id 136:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 165
Counter: 166
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 2483
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (prev);
}


BasicTester, a patch instance with id 137:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (prev);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 166
Counter: 167
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 2483
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (end);
}


BasicTester, a patch instance with id 138:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (end);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 167
Counter: 168
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 2483
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (p);
}


BasicTester, a patch instance with id 139:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (p);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 168
Counter: 169
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 2483
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (prev);
}


BasicTester, a patch instance with id 140:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (prev);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 169
Counter: 170
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 2483
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (buf);
}


BasicTester, a patch instance with id 141:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (buf);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 170
Counter: 171
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 2483
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (end);
}


BasicTester, a patch instance with id 142:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (end);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 171
Counter: 172
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 2483
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (buf);
}


BasicTester, a patch instance with id 143:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (buf);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 172
Counter: 173
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 2483
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (p);
}


BasicTester, a patch instance with id 144:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (p);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 173
Counter: 174
Batcher Size:53
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
mbstate_t cur_state;


BasicTester, a patch instance with id 145:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
xalloc_die();
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 174
Counter: 175
Batcher Size:54
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
prev = p;
mbstate_t cur_state;


BasicTester, a patch instance with id 146:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
prev = p;
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 175
Counter: 176
Batcher Size:55
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
prev = (prev);
mbstate_t cur_state;


BasicTester, a patch instance with id 147:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
prev = (prev);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 176
Counter: 177
Batcher Size:56
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
prev = (p);
mbstate_t cur_state;


BasicTester, a patch instance with id 148:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
prev = (p);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 177
Counter: 178
Batcher Size:57
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
prev = (buf);
mbstate_t cur_state;


BasicTester, a patch instance with id 149:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
prev = (buf);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 178
Counter: 179
Batcher Size:58
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
prev = (end);
mbstate_t cur_state;


BasicTester, a patch instance with id 150:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
prev = (end);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 179
Counter: 180
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
*good = prev;
mbstate_t cur_state;


BasicTester, a patch instance with id 151:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
*good = prev;
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 180
Counter: 181
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);
mbstate_t cur_state;


BasicTester, a patch instance with id 152:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
*good = (prev);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 181
Counter: 182
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
mbstate_t cur_state;


BasicTester, a patch instance with id 153:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
*good = (end);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 182
Counter: 183
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
*good = (p);
mbstate_t cur_state;


BasicTester, a patch instance with id 154:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
*good = (p);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 183
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  //prophet generated patch
  if (__get_mutant()==0) {
  xalloc_die();
  mbstate_t cur_state;
  }
  else if (__get_mutant()==1) {
  prev = p;
  mbstate_t cur_state;
  }
  else if (__get_mutant()==2) {
  prev = (prev);
  mbstate_t cur_state;
  }
  else if (__get_mutant()==3) {
  prev = (p);
  mbstate_t cur_state;
  }
  else if (__get_mutant()==4) {
  prev = (buf);
  mbstate_t cur_state;
  }
  else if (__get_mutant()==5) {
  prev = (end);
  mbstate_t cur_state;
  }
  else if (__get_mutant()==6) {
  *good = prev;
  mbstate_t cur_state;
  }
  else if (__get_mutant()==7) {
  *good = (prev);
  mbstate_t cur_state;
  }
  else if (__get_mutant()==8) {
  *good = (end);
  mbstate_t cur_state;
  }
  else if (__get_mutant()==9) {
  *good = (p);
  mbstate_t cur_state;
  }

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 145:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
xalloc_die();
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 146:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
prev = p;
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 147:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
prev = (prev);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 148:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
prev = (p);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 149:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
prev = (buf);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 150:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
prev = (end);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 151:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
*good = prev;
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 152:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
*good = (prev);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 153:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
*good = (end);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 154:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
*good = (p);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 184
Batcher Size:53
Preprocess the following candidate with BasicTester:
Priority -1
At location src/searchutils.c:123
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
mbstate_t cur_state;


BasicTester, a patch instance with id 155:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
*good = (buf);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 184
Counter: 185
Batcher Size:54
Preprocess the following candidate with BasicTester:
Priority -2
At location src/searchutils.c:122
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
const char *prev = p;


BasicTester, a patch instance with id 156:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  
//Patch 0:
*good = (buf);
const char *prev = p;

//CodeSeg 1:
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 185
Counter: 186
Batcher Size:55
Preprocess the following candidate with BasicTester:
Priority -2
At location src/searchutils.c:122
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
const char *prev = p;


BasicTester, a patch instance with id 157:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  
//Patch 0:
xalloc_die();
const char *prev = p;

//CodeSeg 1:
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 186
Counter: 187
Batcher Size:56
Preprocess the following candidate with BasicTester:
Priority -2
At location src/searchutils.c:122
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
const char *prev = p;


BasicTester, a patch instance with id 158:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  
//Patch 0:
*good = (end);
const char *prev = p;

//CodeSeg 1:
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 187
Counter: 188
Batcher Size:57
Preprocess the following candidate with BasicTester:
Priority -2
At location src/searchutils.c:122
--Src File: src/searchutils.c
Fragment 0:
*good = (p);
const char *prev = p;


BasicTester, a patch instance with id 159:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  
//Patch 0:
*good = (p);
const char *prev = p;

//CodeSeg 1:
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 188
Counter: 189
Batcher Size:58
Preprocess the following candidate with BasicTester:
Priority -3
At location src/searchutils.c:121
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
const char *p = *good;


BasicTester, a patch instance with id 160:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  
//Patch 0:
xalloc_die();
const char *p = *good;

//CodeSeg 1:
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 189
Counter: 190
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority -3
At location src/searchutils.c:121
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
const char *p = *good;


BasicTester, a patch instance with id 161:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  
//Patch 0:
*good = (end);
const char *p = *good;

//CodeSeg 1:
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 190
Counter: 191
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority -3
At location src/searchutils.c:121
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
const char *p = *good;


BasicTester, a patch instance with id 162:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  
//Patch 0:
*good = (buf);
const char *p = *good;

//CodeSeg 1:
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 191
Counter: 192
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    xalloc_die();
    return 1;
}


BasicTester, a patch instance with id 163:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    xalloc_die();
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 192
Counter: 193
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    prev = p;
    return 1;
}


BasicTester, a patch instance with id 164:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    prev = p;
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 193
Counter: 194
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (prev);
    return 1;
}


BasicTester, a patch instance with id 165:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    prev = (prev);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 194
Counter: 195
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    memset(&cur_state, 0, sizeof(mbstate_t));
    return 1;
}


BasicTester, a patch instance with id 166:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    memset(&cur_state, 0, sizeof(mbstate_t));
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 195
Counter: 196
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (end);
    return 1;
}


BasicTester, a patch instance with id 167:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    prev = (end);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 196
Counter: 197
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (buf);
    return 1;
}


BasicTester, a patch instance with id 168:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    prev = (buf);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 197
Counter: 198
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
        return 1;
    return 1;
}


BasicTester, a patch instance with id 169:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
        return 1;
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 198
Counter: 199
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    *good = (prev);
    return 1;
}


BasicTester, a patch instance with id 170:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    *good = (prev);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 199
Counter: 200
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    *good = (buf);
    return 1;
}


BasicTester, a patch instance with id 171:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    *good = (buf);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 200
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	//prophet generated patch
  	if (__get_mutant()==0) {
  	{
  	    if (!(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
  	        return 1;
  	}
  	}
  	else if (__get_mutant()==1) {
  	{
  	    xalloc_die();
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==2) {
  	{
  	    prev = p;
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==3) {
  	{
  	    prev = (prev);
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==4) {
  	{
  	    memset(&cur_state, 0, sizeof(mbstate_t));
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==5) {
  	{
  	    prev = (end);
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==6) {
  	{
  	    prev = (buf);
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==7) {
  	{
  	    if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
  	        return 1;
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==8) {
  	{
  	    *good = (prev);
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==9) {
  	{
  	    *good = (buf);
  	    return 1;
  	}
  	}
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 12:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    if (!(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
        return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 163:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    xalloc_die();
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 164:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    prev = p;
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 165:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    prev = (prev);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 166:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    memset(&cur_state, 0, sizeof(mbstate_t));
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 167:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    prev = (end);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 168:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    prev = (buf);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 169:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
        return 1;
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 170:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    *good = (prev);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 171:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    *good = (buf);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 201
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    *good = (end);
    return 1;
}


BasicTester, a patch instance with id 172:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    *good = (end);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 201
Counter: 202
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    memset(&cur_state, 0, sizeof cur_state);
    return 1;
}


BasicTester, a patch instance with id 173:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    memset(&cur_state, 0, sizeof cur_state);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 202
Counter: 203
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    *good = prev;
    return 1;
}


BasicTester, a patch instance with id 174:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    *good = prev;
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 203
Counter: 204
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    *good = (p);
    return 1;
}


BasicTester, a patch instance with id 175:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    *good = (p);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 204
Counter: 205
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -12
At location src/searchutils.c:147
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (p);
    return 1;
}


BasicTester, a patch instance with id 176:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    prev = (p);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 205
Counter: 206
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 177:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 206
Counter: 207
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 178:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
*good = (prev);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 207
Counter: 208
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
prev = (prev);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 179:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
prev = (prev);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 208
Counter: 209
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof(mbstate_t));
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 180:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 209
Counter: 210
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 181:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
*good = (buf);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 210
Counter: 211
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof cur_state);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 182:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 211
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  //prophet generated patch
  if (__get_mutant()==0) {
  if ((p > buf || match_len < mbrlen(p, end - p, &cur_state)) && !(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
      return 1;
  }
  else if (__get_mutant()==1) {
  if ((p > buf || match_len < mbrlen(p, end - p, &cur_state)) || (__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
      return 1;
  }
  else if (__get_mutant()==2) {
  if (!(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))) && (p > buf || match_len < mbrlen(p, end - p, &cur_state)))
      return 1;
  }
  else if (__get_mutant()==3) {
  if (!(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
      if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
          return 1;
  }
  else if (__get_mutant()==4) {
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==5) {
  *good = (prev);
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==6) {
  prev = (prev);
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==7) {
  memset(&cur_state, 0, sizeof(mbstate_t));
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==8) {
  *good = (buf);
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==9) {
  memset(&cur_state, 0, sizeof cur_state);
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 5:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
if ((p > buf || match_len < mbrlen(p, end - p, &cur_state)) && !(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 6:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
if ((p > buf || match_len < mbrlen(p, end - p, &cur_state)) || (__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 13:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
if (!(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))) && (p > buf || match_len < mbrlen(p, end - p, &cur_state)))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 14:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
if (!(__is_neg(6, &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p), &(good), sizeof (good), &(prev), sizeof (prev))))
    if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
        return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 177:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 178:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
*good = (prev);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 179:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
prev = (prev);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 180:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 181:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
*good = (buf);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 182:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 212
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
prev = p;
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 183:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
prev = p;
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 212
Counter: 213
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 184:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
xalloc_die();
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 213
Counter: 214
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
prev = (p);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 185:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
prev = (p);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 214
Counter: 215
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
prev = (buf);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 186:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
prev = (buf);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 215
Counter: 216
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
*good = prev;
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 187:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
*good = prev;
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 216
Counter: 217
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
*good = (p);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 188:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
*good = (p);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 217
Counter: 218
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 189:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
*good = (end);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 218
Counter: 219
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -13
At location src/searchutils.c:146
--Src File: src/searchutils.c
Fragment 0:
prev = (end);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;


BasicTester, a patch instance with id 190:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
prev = (end);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 219
Counter: 220
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
prev = (buf);
*good = prev;


BasicTester, a patch instance with id 191:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
prev = (buf);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 220
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  //prophet generated patch
  if (__get_mutant()==0) {
  if (!(__is_neg(6, &(good), sizeof (good), &(prev), sizeof (prev), &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p))))
      *good = prev;
  }
  else if (__get_mutant()==1) {
  *good = (prev);
  }
  else if (__get_mutant()==2) {
  *good = (prev);
  }
  else if (__get_mutant()==3) {
  *good = (p);
  }
  else if (__get_mutant()==4) {
  *good = (end);
  }
  else if (__get_mutant()==5) {
  *good = (buf);
  }
  else if (__get_mutant()==6) {
  *good = (p);
  }
  else if (__get_mutant()==7) {
  *good = (end);
  }
  else if (__get_mutant()==8) {
  *good = (buf);
  }
  else if (__get_mutant()==9) {
  prev = (buf);
  *good = prev;
  }
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 15:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
if (!(__is_neg(6, &(good), sizeof (good), &(prev), sizeof (prev), &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len), &(p), sizeof (p))))
    *good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 128:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (prev);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 129:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (prev);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 130:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (p);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 131:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (end);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 132:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (buf);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 133:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (p);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 134:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (end);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 135:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (buf);

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 191:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
prev = (buf);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 221
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof cur_state);
*good = prev;


BasicTester, a patch instance with id 192:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 221
Counter: 222
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = prev;
*good = prev;


BasicTester, a patch instance with id 193:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = prev;
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 222
Counter: 223
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
*good = prev;


BasicTester, a patch instance with id 194:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (buf);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 223
Counter: 224
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (p);
*good = prev;


BasicTester, a patch instance with id 195:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (p);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 224
Counter: 225
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
prev = p;
*good = prev;


BasicTester, a patch instance with id 196:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
prev = p;
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 225
Counter: 226
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
prev = (end);
*good = prev;


BasicTester, a patch instance with id 197:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
prev = (end);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 226
Counter: 227
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
*good = prev;


BasicTester, a patch instance with id 198:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
xalloc_die();
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 227
Counter: 228
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
prev = (prev);
*good = prev;


BasicTester, a patch instance with id 199:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
prev = (prev);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 228
Counter: 229
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof(mbstate_t));
*good = prev;


BasicTester, a patch instance with id 200:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 229
Counter: 230
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
*good = prev;


BasicTester, a patch instance with id 201:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 230
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  //prophet generated patch
  if (__get_mutant()==0) {
  memset(&cur_state, 0, sizeof cur_state);
  *good = prev;
  }
  else if (__get_mutant()==1) {
  *good = prev;
  *good = prev;
  }
  else if (__get_mutant()==2) {
  *good = (buf);
  *good = prev;
  }
  else if (__get_mutant()==3) {
  *good = (p);
  *good = prev;
  }
  else if (__get_mutant()==4) {
  prev = p;
  *good = prev;
  }
  else if (__get_mutant()==5) {
  prev = (end);
  *good = prev;
  }
  else if (__get_mutant()==6) {
  xalloc_die();
  *good = prev;
  }
  else if (__get_mutant()==7) {
  prev = (prev);
  *good = prev;
  }
  else if (__get_mutant()==8) {
  memset(&cur_state, 0, sizeof(mbstate_t));
  *good = prev;
  }
  else if (__get_mutant()==9) {
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  *good = prev;
  }
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 192:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 193:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = prev;
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 194:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (buf);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 195:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (p);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 196:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
prev = p;
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 197:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
prev = (end);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 198:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
xalloc_die();
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 199:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
prev = (prev);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 200:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 201:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 231
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);
*good = prev;


BasicTester, a patch instance with id 202:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (prev);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 231
Counter: 232
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
*good = prev;


BasicTester, a patch instance with id 203:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (end);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 232
Counter: 233
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -14
At location src/searchutils.c:145
--Src File: src/searchutils.c
Fragment 0:
prev = (p);
*good = prev;


BasicTester, a patch instance with id 204:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
prev = (p);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 233
Counter: 234
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}
p += mbclen;


BasicTester, a patch instance with id 205:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 234
Counter: 235
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
if (mbclen != (size_t)-2)
    prev = p;
p += mbclen;


BasicTester, a patch instance with id 206:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
if (mbclen != (size_t)-2)
    prev = p;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 235
Counter: 236
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
*good = (p);
p += mbclen;


BasicTester, a patch instance with id 207:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
*good = (p);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 236
Counter: 237
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
mbclen = (2);
p += mbclen;


BasicTester, a patch instance with id 208:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (2);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 237
Counter: 238
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
prev = (prev);
p += mbclen;


BasicTester, a patch instance with id 209:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
prev = (prev);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 238
Counter: 239
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
p += mbclen;


BasicTester, a patch instance with id 210:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
xalloc_die();
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 239
Counter: 240
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
prev = p;
p += mbclen;


BasicTester, a patch instance with id 211:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
prev = p;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 240
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      //prophet generated patch
      if (__get_mutant()==0) {
      if ((__is_neg(7, &(p), sizeof (p), &(mbclen), sizeof (mbclen), &(good), sizeof (good), &(prev), sizeof (prev), &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len))))
          break;
      p += mbclen;
      }
      else if (__get_mutant()==1) {
      if (!(__is_neg(7, &(p), sizeof (p), &(mbclen), sizeof (mbclen), &(good), sizeof (good), &(prev), sizeof (prev), &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len))))
          p += mbclen;
      }
      else if (__get_mutant()==2) {
      p += mbclen;
      }
      else if (__get_mutant()==3) {
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      p += mbclen;
      }
      else if (__get_mutant()==4) {
      if (mbclen != (size_t)-2)
          prev = p;
      p += mbclen;
      }
      else if (__get_mutant()==5) {
      *good = (p);
      p += mbclen;
      }
      else if (__get_mutant()==6) {
      mbclen = (2);
      p += mbclen;
      }
      else if (__get_mutant()==7) {
      prev = (prev);
      p += mbclen;
      }
      else if (__get_mutant()==8) {
      xalloc_die();
      p += mbclen;
      }
      else if (__get_mutant()==9) {
      prev = p;
      p += mbclen;
      }
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 16:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
if ((__is_neg(7, &(p), sizeof (p), &(mbclen), sizeof (mbclen), &(good), sizeof (good), &(prev), sizeof (prev), &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len))))
    break;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 17:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
if (!(__is_neg(7, &(p), sizeof (p), &(mbclen), sizeof (mbclen), &(good), sizeof (good), &(prev), sizeof (prev), &(buf), sizeof (buf), &(end), sizeof (end), &(match_len), sizeof (match_len))))
    p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 136:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 205:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 206:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
if (mbclen != (size_t)-2)
    prev = p;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 207:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
*good = (p);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 208:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (2);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 209:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
prev = (prev);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 210:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
xalloc_die();
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 211:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
prev = p;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 241
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
prev = (p);
p += mbclen;


BasicTester, a patch instance with id 212:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
prev = (p);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 241
Counter: 242
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof(mbstate_t));
p += mbclen;


BasicTester, a patch instance with id 213:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 242
Counter: 243
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
prev = (end);
p += mbclen;


BasicTester, a patch instance with id 214:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
prev = (end);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 243
Counter: 244
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
mbclen = (match_len);
p += mbclen;


BasicTester, a patch instance with id 215:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (match_len);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 244
Counter: 245
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
prev = (buf);
p += mbclen;


BasicTester, a patch instance with id 216:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
prev = (buf);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 245
Counter: 246
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
mbclen = (1);
p += mbclen;


BasicTester, a patch instance with id 217:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (1);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 246
Counter: 247
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
mbclen = 1;
p += mbclen;


BasicTester, a patch instance with id 218:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = 1;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 247
Counter: 248
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
mbclen = (mbclen);
p += mbclen;


BasicTester, a patch instance with id 219:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (mbclen);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 248
Counter: 249
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
mbclen = (0);
p += mbclen;


BasicTester, a patch instance with id 220:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (0);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 249
Counter: 250
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
mbclen = (-2);
p += mbclen;


BasicTester, a patch instance with id 221:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (-2);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 250
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      //prophet generated patch
      if (__get_mutant()==0) {
      prev = (p);
      p += mbclen;
      }
      else if (__get_mutant()==1) {
      memset(&cur_state, 0, sizeof(mbstate_t));
      p += mbclen;
      }
      else if (__get_mutant()==2) {
      prev = (end);
      p += mbclen;
      }
      else if (__get_mutant()==3) {
      mbclen = (match_len);
      p += mbclen;
      }
      else if (__get_mutant()==4) {
      prev = (buf);
      p += mbclen;
      }
      else if (__get_mutant()==5) {
      mbclen = (1);
      p += mbclen;
      }
      else if (__get_mutant()==6) {
      mbclen = 1;
      p += mbclen;
      }
      else if (__get_mutant()==7) {
      mbclen = (mbclen);
      p += mbclen;
      }
      else if (__get_mutant()==8) {
      mbclen = (0);
      p += mbclen;
      }
      else if (__get_mutant()==9) {
      mbclen = (-2);
      p += mbclen;
      }
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 212:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
prev = (p);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 213:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 214:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
prev = (end);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 215:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (match_len);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 216:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
prev = (buf);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 217:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (1);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 218:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = 1;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 219:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (mbclen);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 220:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (0);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 221:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (-2);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 251
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
p += mbclen;


BasicTester, a patch instance with id 222:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 251
Counter: 252
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
p += mbclen;


BasicTester, a patch instance with id 223:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
*good = (end);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 252
Counter: 253
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);
p += mbclen;


BasicTester, a patch instance with id 224:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
*good = (prev);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 253
Counter: 254
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof cur_state);
p += mbclen;


BasicTester, a patch instance with id 225:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 254
Counter: 255
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
mbclen = (-1);
p += mbclen;


BasicTester, a patch instance with id 226:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (-1);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 255
Counter: 256
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
*good = prev;
p += mbclen;


BasicTester, a patch instance with id 227:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
*good = prev;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 256
Counter: 257
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -15
At location src/searchutils.c:142
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
p += mbclen;


BasicTester, a patch instance with id 228:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
*good = (buf);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 257
Counter: 258
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
mbclen = (mbclen);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 229:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (mbclen);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 258
Counter: 259
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
mbclen = (2);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 230:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (2);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 259
Counter: 260
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
mbclen = (match_len);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 231:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (match_len);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 260
Counter: 261
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 232:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
*good = (buf);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 261
Counter: 262
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
prev = (p);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 233:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
prev = (p);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 262
Counter: 263
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
prev = (prev);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 234:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
prev = (prev);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 263
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      //prophet generated patch
      if (__get_mutant()==0) {
      if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) && !(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len)))) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==1) {
      if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) || (__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len)))) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==2) {
      if (!(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
      }
      else if (__get_mutant()==3) {
      if (!(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))) && (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0)) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==4) {
      mbclen = (mbclen);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==5) {
      mbclen = (2);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==6) {
      mbclen = (match_len);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==7) {
      *good = (buf);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==8) {
      prev = (p);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==9) {
      prev = (prev);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 9:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) && !(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len)))) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 10:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if ((mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) || (__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len)))) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 18:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if (!(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
    if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
        mbclen = 1;
        memset(&cur_state, 0, sizeof cur_state);
    }

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 19:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if (!(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))) && (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0)) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 229:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (mbclen);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 230:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (2);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 231:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (match_len);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 232:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
*good = (buf);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 233:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
prev = (p);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 234:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
prev = (prev);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 264
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
prev = p;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 235:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
prev = p;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 264
Counter: 265
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 236:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
xalloc_die();
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 265
Counter: 266
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
prev = (end);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 237:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
prev = (end);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 266
Counter: 267
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof(mbstate_t));
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 238:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 267
Counter: 268
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
prev = (buf);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 239:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
prev = (buf);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 268
Counter: 269
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
mbclen = 1;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 240:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = 1;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 269
Counter: 270
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof cur_state);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 241:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 270
Counter: 271
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
mbclen = (1);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 242:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (1);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 271
Counter: 272
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
if (mbclen != (size_t)-2)
    prev = p;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 243:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if (mbclen != (size_t)-2)
    prev = p;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 272
Counter: 273
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
mbclen = (-2);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 244:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (-2);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 273
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      //prophet generated patch
      if (__get_mutant()==0) {
      prev = p;
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==1) {
      xalloc_die();
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==2) {
      prev = (end);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==3) {
      memset(&cur_state, 0, sizeof(mbstate_t));
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==4) {
      prev = (buf);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==5) {
      mbclen = 1;
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==6) {
      memset(&cur_state, 0, sizeof cur_state);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==7) {
      mbclen = (1);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==8) {
      if (mbclen != (size_t)-2)
          prev = p;
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==9) {
      mbclen = (-2);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 235:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
prev = p;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 236:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
xalloc_die();
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 237:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
prev = (end);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 238:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 239:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
prev = (buf);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 240:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = 1;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 241:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 242:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (1);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 243:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if (mbclen != (size_t)-2)
    prev = p;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 244:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (-2);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 274
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
mbclen = (0);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 245:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (0);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 274
Counter: 275
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
mbclen = (-1);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 246:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (-1);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 275
Counter: 276
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 247:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 276
Counter: 277
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 248:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 277
Counter: 278
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
*good = (p);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 249:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
*good = (p);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 278
Counter: 279
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
*good = prev;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 250:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
*good = prev;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 279
Counter: 280
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 251:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
*good = (prev);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 280
Counter: 281
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -16
At location src/searchutils.c:135
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}


BasicTester, a patch instance with id 252:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
*good = (end);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 281
Counter: 282
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    xalloc_die();
    prev = p;
}


BasicTester, a patch instance with id 253:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    xalloc_die();
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 282
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        //prophet generated patch
        if (__get_mutant()==0) {
        {
            if (!(__is_neg(7, &(p), sizeof (p), &(prev), sizeof (prev), &(mbclen), sizeof (mbclen), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
                prev = p;
        }
        }
        else if (__get_mutant()==1) {
        {
            prev = (prev);
        }
        }
        else if (__get_mutant()==2) {
        {
            prev = (end);
        }
        }
        else if (__get_mutant()==3) {
        {
            prev = (p);
        }
        }
        else if (__get_mutant()==4) {
        {
            prev = (prev);
        }
        }
        else if (__get_mutant()==5) {
        {
            prev = (buf);
        }
        }
        else if (__get_mutant()==6) {
        {
            prev = (end);
        }
        }
        else if (__get_mutant()==7) {
        {
            prev = (buf);
        }
        }
        else if (__get_mutant()==8) {
        {
            prev = (p);
        }
        }
        else if (__get_mutant()==9) {
        {
            xalloc_die();
            prev = p;
        }
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 20:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    if (!(__is_neg(7, &(p), sizeof (p), &(prev), sizeof (prev), &(mbclen), sizeof (mbclen), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
        prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 137:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (prev);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 138:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (end);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 139:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (p);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 140:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (prev);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 141:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (buf);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 142:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (end);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 143:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (buf);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 144:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (p);
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 253:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    xalloc_die();
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 283
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (prev);
    prev = p;
}


BasicTester, a patch instance with id 254:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (prev);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 283
Counter: 284
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    memset(&cur_state, 0, sizeof cur_state);
    prev = p;
}


BasicTester, a patch instance with id 255:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    memset(&cur_state, 0, sizeof cur_state);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 284
Counter: 285
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    mbclen = 1;
    prev = p;
}


BasicTester, a patch instance with id 256:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = 1;
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 285
Counter: 286
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    mbclen = (1);
    prev = p;
}


BasicTester, a patch instance with id 257:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (1);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 286
Counter: 287
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
        return 1;
    prev = p;
}


BasicTester, a patch instance with id 258:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
        return 1;
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 287
Counter: 288
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    *good = prev;
    prev = p;
}


BasicTester, a patch instance with id 259:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    *good = prev;
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 288
Counter: 289
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    *good = (prev);
    prev = p;
}


BasicTester, a patch instance with id 260:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    *good = (prev);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 289
Counter: 290
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    mbclen = (-2);
    prev = p;
}


BasicTester, a patch instance with id 261:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (-2);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 290
Counter: 291
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    mbclen = (match_len);
    prev = p;
}


BasicTester, a patch instance with id 262:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (match_len);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 291
Counter: 292
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    mbclen = (0);
    prev = p;
}


BasicTester, a patch instance with id 263:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (0);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 292
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        //prophet generated patch
        if (__get_mutant()==0) {
        {
            prev = (prev);
            prev = p;
        }
        }
        else if (__get_mutant()==1) {
        {
            memset(&cur_state, 0, sizeof cur_state);
            prev = p;
        }
        }
        else if (__get_mutant()==2) {
        {
            mbclen = 1;
            prev = p;
        }
        }
        else if (__get_mutant()==3) {
        {
            mbclen = (1);
            prev = p;
        }
        }
        else if (__get_mutant()==4) {
        {
            if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
                return 1;
            prev = p;
        }
        }
        else if (__get_mutant()==5) {
        {
            *good = prev;
            prev = p;
        }
        }
        else if (__get_mutant()==6) {
        {
            *good = (prev);
            prev = p;
        }
        }
        else if (__get_mutant()==7) {
        {
            mbclen = (-2);
            prev = p;
        }
        }
        else if (__get_mutant()==8) {
        {
            mbclen = (match_len);
            prev = p;
        }
        }
        else if (__get_mutant()==9) {
        {
            mbclen = (0);
            prev = p;
        }
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 254:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (prev);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 255:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    memset(&cur_state, 0, sizeof cur_state);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 256:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = 1;
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 257:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (1);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 258:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
        return 1;
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 259:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    *good = prev;
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 260:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    *good = (prev);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 261:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (-2);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 262:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (match_len);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 263:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (0);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 293
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    mbclen = (2);
    prev = p;
}


BasicTester, a patch instance with id 264:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (2);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 293
Counter: 294
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
        mbclen = 1;
        memset(&cur_state, 0, sizeof cur_state);
    }
    prev = p;
}


BasicTester, a patch instance with id 265:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
        mbclen = 1;
        memset(&cur_state, 0, sizeof cur_state);
    }
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 294
Counter: 295
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    if (mbclen != (size_t)-2)
        prev = p;
    prev = p;
}


BasicTester, a patch instance with id 266:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    if (mbclen != (size_t)-2)
        prev = p;
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 295
Counter: 296
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    memset(&cur_state, 0, sizeof(mbstate_t));
    prev = p;
}


BasicTester, a patch instance with id 267:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    memset(&cur_state, 0, sizeof(mbstate_t));
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 296
Counter: 297
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (end);
    prev = p;
}


BasicTester, a patch instance with id 268:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (end);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 297
Counter: 298
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = p;
    prev = p;
}


BasicTester, a patch instance with id 269:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = p;
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 298
Counter: 299
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (p);
    prev = p;
}


BasicTester, a patch instance with id 270:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (p);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 299
Counter: 300
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    mbclen = (mbclen);
    prev = p;
}


BasicTester, a patch instance with id 271:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (mbclen);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 300
Counter: 301
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    mbclen = (-1);
    prev = p;
}


BasicTester, a patch instance with id 272:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (-1);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 301
Counter: 302
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    *good = (end);
    prev = p;
}


BasicTester, a patch instance with id 273:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    *good = (end);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 302
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        //prophet generated patch
        if (__get_mutant()==0) {
        {
            mbclen = (2);
            prev = p;
        }
        }
        else if (__get_mutant()==1) {
        {
            if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
                mbclen = 1;
                memset(&cur_state, 0, sizeof cur_state);
            }
            prev = p;
        }
        }
        else if (__get_mutant()==2) {
        {
            if (mbclen != (size_t)-2)
                prev = p;
            prev = p;
        }
        }
        else if (__get_mutant()==3) {
        {
            memset(&cur_state, 0, sizeof(mbstate_t));
            prev = p;
        }
        }
        else if (__get_mutant()==4) {
        {
            prev = (end);
            prev = p;
        }
        }
        else if (__get_mutant()==5) {
        {
            prev = p;
            prev = p;
        }
        }
        else if (__get_mutant()==6) {
        {
            prev = (p);
            prev = p;
        }
        }
        else if (__get_mutant()==7) {
        {
            mbclen = (mbclen);
            prev = p;
        }
        }
        else if (__get_mutant()==8) {
        {
            mbclen = (-1);
            prev = p;
        }
        }
        else if (__get_mutant()==9) {
        {
            *good = (end);
            prev = p;
        }
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 264:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (2);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 265:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
        mbclen = 1;
        memset(&cur_state, 0, sizeof cur_state);
    }
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 266:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    if (mbclen != (size_t)-2)
        prev = p;
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 267:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    memset(&cur_state, 0, sizeof(mbstate_t));
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 268:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (end);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 269:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = p;
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 270:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (p);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 271:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (mbclen);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 272:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    mbclen = (-1);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 273:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    *good = (end);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 303
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    *good = (buf);
    prev = p;
}


BasicTester, a patch instance with id 274:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    *good = (buf);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 303
Counter: 304
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    *good = (p);
    prev = p;
}


BasicTester, a patch instance with id 275:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    *good = (p);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 304
Counter: 305
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -17
At location src/searchutils.c:133
--Src File: src/searchutils.c
Fragment 0:
{
    prev = (buf);
    prev = p;
}


BasicTester, a patch instance with id 276:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (buf);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 305
Counter: 306
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 277:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
*good = (buf);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 306
Counter: 307
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 278:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
*good = (end);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 307
Counter: 308
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
prev = p;
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 279:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
prev = p;
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 308
Counter: 309
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
prev = (p);
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 280:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
prev = (p);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 309
Counter: 310
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof(mbstate_t));
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 281:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 310
Counter: 311
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof cur_state);
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 282:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 311
Counter: 312
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 283:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
*good = (prev);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 312
Counter: 313
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
prev = (end);
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 284:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
prev = (end);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 313
Counter: 314
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 285:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 314
Counter: 315
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
prev = (prev);
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 286:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
prev = (prev);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 315
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      //prophet generated patch
      if (__get_mutant()==0) {
      *good = (buf);
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==1) {
      *good = (end);
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==2) {
      prev = p;
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==3) {
      prev = (p);
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==4) {
      memset(&cur_state, 0, sizeof(mbstate_t));
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==5) {
      memset(&cur_state, 0, sizeof cur_state);
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==6) {
      *good = (prev);
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==7) {
      prev = (end);
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==8) {
      if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
          return 1;
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==9) {
      prev = (prev);
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 277:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
*good = (buf);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 278:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
*good = (end);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 279:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
prev = p;
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 280:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
prev = (p);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 281:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 282:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 283:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
*good = (prev);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 284:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
prev = (end);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 285:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 286:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
prev = (prev);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 316
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
prev = (buf);
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 287:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
prev = (buf);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 316
Counter: 317
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
*good = (p);
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 288:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
*good = (p);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 317
Counter: 318
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 289:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
xalloc_die();
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 318
Counter: 319
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -19
At location src/searchutils.c:129
--Src File: src/searchutils.c
Fragment 0:
*good = prev;
size_t mbclen = mbrlen(p, end - p, &cur_state);


BasicTester, a patch instance with id 290:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
*good = prev;
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 319
Counter: 320
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
*good = (prev);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 291:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
*good = (prev);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 320
Counter: 321
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 292:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 321
Counter: 322
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof(mbstate_t));
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 293:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 322
Counter: 323
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
*good = (p);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 294:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
*good = (p);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 323
Counter: 324
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 295:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
xalloc_die();
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 324
Counter: 325
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
*good = (buf);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 296:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
*good = (buf);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 325
Counter: 326
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
*good = (end);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 297:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
*good = (end);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 326
Counter: 327
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
prev = (prev);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 298:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
prev = (prev);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 327
Counter: 328
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
prev = (end);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 299:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
prev = (end);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 328
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  //prophet generated patch
  if (__get_mutant()==0) {
  if (!(__is_neg(6, &(buf), sizeof (buf), &(p), sizeof (p), &(end), sizeof (end), &(good), sizeof (good), &(prev), sizeof (prev), &(match_len), sizeof (match_len))))
      while (p < buf)
          {
              size_t mbclen = mbrlen(p, end - p, &cur_state);
              if (mbclen != (size_t)-2)
                  prev = p;
              if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
                  mbclen = 1;
                  memset(&cur_state, 0, sizeof cur_state);
              }
              p += mbclen;
          }
  }
  else if (__get_mutant()==1) {
  *good = (prev);
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==2) {
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==3) {
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==4) {
  *good = (p);
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==5) {
  xalloc_die();
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==6) {
  *good = (buf);
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==7) {
  *good = (end);
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==8) {
  prev = (prev);
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==9) {
  prev = (end);
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 22:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
if (!(__is_neg(6, &(buf), sizeof (buf), &(p), sizeof (p), &(end), sizeof (end), &(good), sizeof (good), &(prev), sizeof (prev), &(match_len), sizeof (match_len))))
    while (p < buf)
        {
            size_t mbclen = mbrlen(p, end - p, &cur_state);
            if (mbclen != (size_t)-2)
                prev = p;
            if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
                mbclen = 1;
                memset(&cur_state, 0, sizeof cur_state);
            }
            p += mbclen;
        }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 291:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
*good = (prev);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 292:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 293:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
memset(&cur_state, 0, sizeof(mbstate_t));
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 294:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
*good = (p);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 295:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
xalloc_die();
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 296:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
*good = (buf);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 297:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
*good = (end);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 298:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
prev = (prev);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 299:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
prev = (end);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 329
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
*good = prev;
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 300:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
*good = prev;
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 329
Counter: 330
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
prev = (buf);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 301:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
prev = (buf);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 330
Counter: 331
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
prev = (p);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 302:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
prev = (p);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 331
Counter: 332
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
memset(&cur_state, 0, sizeof cur_state);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 303:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 332
Counter: 333
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority -20
At location src/searchutils.c:127
--Src File: src/searchutils.c
Fragment 0:
prev = p;
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }


BasicTester, a patch instance with id 304:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
prev = p;
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 333
Counter: 334
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
    int __res;
    if (sizeof (i) > 1) {
        if (__builtin_constant_p(i)) {
            int __c = (i);
            __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
        } else
            __res = tolower(i);
    } else
        __res = (*__ctype_tolower_loc())[(int)(i)];
    __res;
})) : (i));
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 305:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
    int __res;
    if (sizeof (i) > 1) {
        if (__builtin_constant_p(i)) {
            int __c = (i);
            __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
        } else
            __res = tolower(i);
    } else
        __res = (*__ctype_tolower_loc())[(int)(i)];
    __res;
})) : (i));
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 334
Counter: 335
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (256);
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 306:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (256);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 335
Counter: 336
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
*kwset = kwsalloc(trans);
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 307:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
*kwset = kwsalloc(trans);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 336
Counter: 337
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 308:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
xalloc_die();
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 337
Counter: 338
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (1);
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 309:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (1);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 338
Counter: 339
Batcher Size:78
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
*kwset = kwsalloc(((void *)0));
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 310:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
*kwset = kwsalloc(((void *)0));
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 339
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  //prophet generated patch
  if (__get_mutant()==0) {
  if ((!*kwset) && !(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
      xalloc_die();
  }
  else if (__get_mutant()==1) {
  if ((!*kwset) || (__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
      xalloc_die();
  }
  else if (__get_mutant()==2) {
  if (!(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))) && (!*kwset))
      xalloc_die();
  }
  else if (__get_mutant()==3) {
  if (!(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
      if (!*kwset)
          xalloc_die();
  }
  else if (__get_mutant()==4) {
  trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
      int __res;
      if (sizeof (i) > 1) {
          if (__builtin_constant_p(i)) {
              int __c = (i);
              __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
          } else
              __res = tolower(i);
      } else
          __res = (*__ctype_tolower_loc())[(int)(i)];
      __res;
  })) : (i));
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==5) {
  trans[i] = (256);
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==6) {
  *kwset = kwsalloc(trans);
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==7) {
  xalloc_die();
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==8) {
  trans[i] = (1);
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==9) {
  *kwset = kwsalloc(((void *)0));
  if (!*kwset)
      xalloc_die();
  }
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 1:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if ((!*kwset) && !(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Not caught by the negative case, give up!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 2:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if ((!*kwset) || (__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Passed!
CondTester, Testing instance id 23:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if (!(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))) && (!*kwset))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 24:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if (!(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    if (!*kwset)
        xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 305:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
    int __res;
    if (sizeof (i) > 1) {
        if (__builtin_constant_p(i)) {
            int __c = (i);
            __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
        } else
            __res = tolower(i);
    } else
        __res = (*__ctype_tolower_loc())[(int)(i)];
    __res;
})) : (i));
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 306:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (256);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 307:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
*kwset = kwsalloc(trans);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 308:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
xalloc_die();
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 309:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (1);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 310:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
*kwset = kwsalloc(((void *)0));
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Postprocessing instance id 2:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if ((!*kwset) || (__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr i == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Initial synthesize failed, final attempt
Skipping two clauses!(1) &&(0)
Found a clause! (!*kwset) 
Skipping a clause! (!*kwset) 
Postprocessing failed!
Counter: 340
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (128);
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 311:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (128);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 340
Counter: 341
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (-128);
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 312:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (-128);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 341
Counter: 342
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (2);
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 313:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (2);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 342
Counter: 343
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
if (!*kwset)
    xalloc_die();
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 314:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if (!*kwset)
    xalloc_die();
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 343
Counter: 344
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (0);
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 315:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (0);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 344
Counter: 345
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (254);
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 316:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (254);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 345
Counter: 346
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (255);
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 317:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (255);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 346
Counter: 347
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority -139
At location src/searchutils.c:45
--Src File: src/searchutils.c
Fragment 0:
trans[i] = (127);
if (!*kwset)
    xalloc_die();


BasicTester, a patch instance with id 318:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (127);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 347
Counter: 348
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    trans[i] = (-128);
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 319:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (-128);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 348
Counter: 349
Batcher Size:78
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
        int __res;
        if (sizeof (i) > 1) {
            if (__builtin_constant_p(i)) {
                int __c = (i);
                __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
            } else
                __res = tolower(i);
        } else
            __res = (*__ctype_tolower_loc())[(int)(i)];
        __res;
    })) : (i));
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 320:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
        int __res;
        if (sizeof (i) > 1) {
            if (__builtin_constant_p(i)) {
                int __c = (i);
                __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
            } else
                __res = tolower(i);
        } else
            __res = (*__ctype_tolower_loc())[(int)(i)];
        __res;
    })) : (i));
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 349
Counter: 350
Batcher Size:79
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    trans[i] = (1);
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 321:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (1);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 350
Counter: 351
Batcher Size:80
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    xalloc_die();
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 322:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    xalloc_die();
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 351
Counter: 352
Batcher Size:81
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    trans[i] = (0);
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 323:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (0);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 352
Counter: 353
Batcher Size:82
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    trans[i] = (256);
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 324:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (256);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 353
Counter: 354
Batcher Size:83
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    trans[i] = (127);
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 325:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (127);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 354
Counter: 355
Batcher Size:84
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    *kwset = kwsalloc(((void *)0));
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 326:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    *kwset = kwsalloc(((void *)0));
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 355
Counter: 356
Batcher Size:85
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    trans[i] = (255);
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 327:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (255);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 356
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    //prophet generated patch
    if (__get_mutant()==0) {
    {
        if (!(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
            *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==1) {
    {
        trans[i] = (-128);
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==2) {
    {
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==3) {
    {
        trans[i] = (1);
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==4) {
    {
        xalloc_die();
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==5) {
    {
        trans[i] = (0);
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==6) {
    {
        trans[i] = (256);
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==7) {
    {
        trans[i] = (127);
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==8) {
    {
        *kwset = kwsalloc(((void *)0));
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==9) {
    {
        trans[i] = (255);
        *kwset = kwsalloc(((void *)0));
    }
    }

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
CondTester, Testing instance id 25:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    if (!(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
        *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Passed!
BasicTester, Testing instance id 319:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (-128);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 320:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
        int __res;
        if (sizeof (i) > 1) {
            if (__builtin_constant_p(i)) {
                int __c = (i);
                __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
            } else
                __res = tolower(i);
        } else
            __res = (*__ctype_tolower_loc())[(int)(i)];
        __res;
    })) : (i));
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 321:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (1);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 322:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    xalloc_die();
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 323:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (0);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 324:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (256);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 325:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (127);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 326:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    *kwset = kwsalloc(((void *)0));
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 327:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (255);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Postprocessing instance id 25:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    if (!(__is_neg(3, &(kwset), sizeof (kwset), &(i), sizeof (i), &(match_icase), sizeof (match_icase))))
        *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr i == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Initial synthesize failed, final attempt
Skipping two clauses!(1) &&(0)
Postprocessing failed!
Counter: 357
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    trans[i] = (254);
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 328:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (254);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 357
Counter: 358
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    *kwset = kwsalloc(trans);
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 329:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    *kwset = kwsalloc(trans);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 358
Counter: 359
Batcher Size:78
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    trans[i] = (2);
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 330:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (2);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 359
Counter: 360
Batcher Size:79
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    if (!*kwset)
        xalloc_die();
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 331:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    if (!*kwset)
        xalloc_die();
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 360
Counter: 361
Batcher Size:80
Preprocess the following candidate with BasicTester:
Priority -174
At location src/searchutils.c:43
--Src File: src/searchutils.c
Fragment 0:
{
    trans[i] = (128);
    *kwset = kwsalloc(((void *)0));
}


BasicTester, a patch instance with id 332:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (128);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 361
Counter: 362
Batcher Size:81
Preprocess the following candidate with BasicTester:
Priority -176
At location src/searchutils.c:29
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
int i;


BasicTester, a patch instance with id 333:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  
//Patch 0:
xalloc_die();
int i;

//CodeSeg 1:

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 362
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 333:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  
//Patch 0:
xalloc_die();
int i;

//CodeSeg 1:

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 363
Batcher Size:81
Preprocess the following candidate with BasicTester:
Priority -176
At location src/searchutils.c:29
--Src File: src/searchutils.c
Fragment 0:
*kwset = kwsalloc(((void *)0));
int i;


BasicTester, a patch instance with id 334:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  
//Patch 0:
*kwset = kwsalloc(((void *)0));
int i;

//CodeSeg 1:

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 363
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 334:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  
//Patch 0:
*kwset = kwsalloc(((void *)0));
int i;

//CodeSeg 1:

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 364
Batcher Size:81
Preprocess the following candidate with BasicTester:
Priority -176
At location src/searchutils.c:29
--Src File: src/searchutils.c
Fragment 0:
*kwset = kwsalloc(trans);
int i;


BasicTester, a patch instance with id 335:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  
//Patch 0:
*kwset = kwsalloc(trans);
int i;

//CodeSeg 1:

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 364
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 335:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  
//Patch 0:
*kwset = kwsalloc(trans);
int i;

//CodeSeg 1:

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Counter: 365
Batcher Size:81
Preprocess the following candidate with BasicTester:
Priority -176
At location src/searchutils.c:29
--Src File: src/searchutils.c
Fragment 0:
if (!*kwset)
    xalloc_die();
int i;


BasicTester, a patch instance with id 336:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  
//Patch 0:
if (!*kwset)
    xalloc_die();
int i;

//CodeSeg 1:

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 365
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 336:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  
//Patch 0:
if (!*kwset)
    xalloc_die();
int i;

//CodeSeg 1:

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Counter: 366
Batcher Size:81
Preprocess the following candidate with BasicTester:
Priority -177
At location src/searchutils.c:28
--Src File: src/searchutils.c
Fragment 0:
xalloc_die();
static char trans[256];


BasicTester, a patch instance with id 337:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  
//Patch 0:
xalloc_die();
static char trans[256];

//CodeSeg 1:
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 366
Counter: 367
Batcher Size:82
Preprocess the following candidate with BasicTester:
Priority -177
At location src/searchutils.c:28
--Src File: src/searchutils.c
Fragment 0:
*kwset = kwsalloc(((void *)0));
static char trans[256];


BasicTester, a patch instance with id 338:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  
//Patch 0:
*kwset = kwsalloc(((void *)0));
static char trans[256];

//CodeSeg 1:
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 367
Counter: 368
Batcher Size:83
Preprocess the following candidate with BasicTester:
Priority -177
At location src/searchutils.c:28
--Src File: src/searchutils.c
Fragment 0:
if (!*kwset)
    xalloc_die();
static char trans[256];


BasicTester, a patch instance with id 339:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  
//Patch 0:
if (!*kwset)
    xalloc_die();
static char trans[256];

//CodeSeg 1:
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Spawn 1 instances, now Total 368
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  //prophet generated patch
  if (__get_mutant()==0) {
  xalloc_die();
  static char trans[256];
  }
  else if (__get_mutant()==1) {
  *kwset = kwsalloc(((void *)0));
  static char trans[256];
  }
  else if (__get_mutant()==2) {
  if (!*kwset)
      xalloc_die();
  static char trans[256];
  }
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 337:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  
//Patch 0:
xalloc_die();
static char trans[256];

//CodeSeg 1:
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 338:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  
//Patch 0:
*kwset = kwsalloc(((void *)0));
static char trans[256];

//CodeSeg 1:
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 339:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  
//Patch 0:
if (!*kwset)
    xalloc_die();
static char trans[256];

//CodeSeg 1:
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  //prophet generated patch
  if (__get_mutant()==0) {
  *kwset = kwsalloc(trans);
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==1) {
  trans[i] = (254);
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==2) {
  trans[i] = (1);
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==3) {
  trans[i] = (127);
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==4) {
  trans[i] = (2);
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==5) {
  trans[i] = (128);
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==6) {
  *kwset = kwsalloc(((void *)0));
  if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==7) {
  if (!(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset))) && (match_icase && (__ctype_get_mb_cur_max()) == 1)) {
      for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
          trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
              int __res;
              if (sizeof (i) > 1) {
                  if (__builtin_constant_p(i)) {
                      int __c = (i);
                      __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                  } else
                      __res = tolower(i);
              } else
                  __res = (*__ctype_tolower_loc())[(int)(i)];
              __res;
          })) : (i));
      *kwset = kwsalloc(trans);
  } else
      *kwset = kwsalloc(((void *)0));
  }
  else if (__get_mutant()==8) {
  if (!(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset))))
      if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
          for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
              trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
                  int __res;
                  if (sizeof (i) > 1) {
                      if (__builtin_constant_p(i)) {
                          int __c = (i);
                          __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                      } else
                          __res = tolower(i);
                  } else
                      __res = (*__ctype_tolower_loc())[(int)(i)];
                  __res;
              })) : (i));
          *kwset = kwsalloc(trans);
      } else
          *kwset = kwsalloc(((void *)0));
  }

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 21:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
*kwset = kwsalloc(trans);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 22:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (254);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 23:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (1);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 24:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (127);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 25:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (2);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 26:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
trans[i] = (128);
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 27:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
*kwset = kwsalloc(((void *)0));
if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 26:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (!(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset))) && (match_icase && (__ctype_get_mb_cur_max()) == 1)) {
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
            int __res;
            if (sizeof (i) > 1) {
                if (__builtin_constant_p(i)) {
                    int __c = (i);
                    __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                } else
                    __res = tolower(i);
            } else
                __res = (*__ctype_tolower_loc())[(int)(i)];
            __res;
        })) : (i));
    *kwset = kwsalloc(trans);
} else
    *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 27:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (!(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset))))
    if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
        for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
            trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
                int __res;
                if (sizeof (i) > 1) {
                    if (__builtin_constant_p(i)) {
                        int __c = (i);
                        __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                    } else
                        __res = tolower(i);
                } else
                    __res = (*__ctype_tolower_loc())[(int)(i)];
                __res;
            })) : (i));
        *kwset = kwsalloc(trans);
    } else
        *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 0
Iteration 1
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Passed Positive Cases
Collect values for post processing!
WRITING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 3  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 4  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 5  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 6  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 13  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 14  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 15  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 17  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 18  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 22  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 23  > __res
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Passed!
CondTester, Postprocessing instance id 27:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  
//Patch 0:
if (!(__is_neg(3, &(match_icase), sizeof (match_icase), &(i), sizeof (i), &(kwset), sizeof (kwset))))
    if (match_icase && (__ctype_get_mb_cur_max()) == 1) {
        for (i = 0; i < ((127 * 2 + 1) + 1); ++i) 
            trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? (__extension__ ({
                int __res;
                if (sizeof (i) > 1) {
                    if (__builtin_constant_p(i)) {
                        int __c = (i);
                        __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc())[__c];
                    } else
                        __res = tolower(i);
                } else
                    __res = (*__ctype_tolower_loc())[(int)(i)];
                __res;
            })) : (i));
        *kwset = kwsalloc(trans);
    } else
        *kwset = kwsalloc(((void *)0));

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Trying a synthesis expr 1
Skipping a synthesis:1
Trying a synthesis expr match_icase == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Trying a synthesis expr i == 0
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcVerifing Negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Verifying positive cases
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 9  > __res
Failed positive case 9
Not passed!
Initial synthesize failed, final attempt
Skipping two clauses!(1) &&(0)
Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    //prophet generated patch
    if (__get_mutant()==0) {
    {
        trans[i] = (254);
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==1) {
    {
        *kwset = kwsalloc(trans);
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==2) {
    {
        trans[i] = (2);
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==3) {
    {
        if (!*kwset)
            xalloc_die();
        *kwset = kwsalloc(((void *)0));
    }
    }
    else if (__get_mutant()==4) {
    {
        trans[i] = (128);
        *kwset = kwsalloc(((void *)0));
    }
    }

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 328:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (254);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 329:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    *kwset = kwsalloc(trans);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 330:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (2);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 331:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    if (!*kwset)
        xalloc_die();
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 332:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    
//Patch 0:
{
    trans[i] = (128);
    *kwset = kwsalloc(((void *)0));
}

//CodeSeg 1:

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  //prophet generated patch
  if (__get_mutant()==0) {
  trans[i] = (128);
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==1) {
  trans[i] = (-128);
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==2) {
  trans[i] = (2);
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==3) {
  if (!*kwset)
      xalloc_die();
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==4) {
  trans[i] = (0);
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==5) {
  trans[i] = (254);
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==6) {
  trans[i] = (255);
  if (!*kwset)
      xalloc_die();
  }
  else if (__get_mutant()==7) {
  trans[i] = (127);
  if (!*kwset)
      xalloc_die();
  }
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 311:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (128);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 312:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (-128);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 313:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (2);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 314:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
if (!*kwset)
    xalloc_die();
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 315:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (0);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 316:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (254);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 317:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (255);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 318:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  
//Patch 0:
trans[i] = (127);
if (!*kwset)
    xalloc_die();

//CodeSeg 1:
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  //prophet generated patch
  if (__get_mutant()==0) {
  xalloc_die();
  const char *p = *good;
  }
  else if (__get_mutant()==1) {
  *good = (end);
  const char *p = *good;
  }
  else if (__get_mutant()==2) {
  *good = (buf);
  const char *p = *good;
  }
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 160:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  
//Patch 0:
xalloc_die();
const char *p = *good;

//CodeSeg 1:
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 161:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  
//Patch 0:
*good = (end);
const char *p = *good;

//CodeSeg 1:
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 162:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  
//Patch 0:
*good = (buf);
const char *p = *good;

//CodeSeg 1:
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  //prophet generated patch
  if (__get_mutant()==0) {
  *good = (buf);
  const char *prev = p;
  }
  else if (__get_mutant()==1) {
  xalloc_die();
  const char *prev = p;
  }
  else if (__get_mutant()==2) {
  *good = (end);
  const char *prev = p;
  }
  else if (__get_mutant()==3) {
  *good = (p);
  const char *prev = p;
  }
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 156:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  
//Patch 0:
*good = (buf);
const char *prev = p;

//CodeSeg 1:
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 157:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  
//Patch 0:
xalloc_die();
const char *prev = p;

//CodeSeg 1:
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 158:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  
//Patch 0:
*good = (end);
const char *prev = p;

//CodeSeg 1:
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 159:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  
//Patch 0:
*good = (p);
const char *prev = p;

//CodeSeg 1:
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  //prophet generated patch
  if (__get_mutant()==0) {
  *good = (buf);
  mbstate_t cur_state;
  }

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 155:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  
//Patch 0:
*good = (buf);
mbstate_t cur_state;

//CodeSeg 1:

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  //prophet generated patch
  if (__get_mutant()==0) {
  memchr(&cur_state, 0, sizeof(mbstate_t));
  }
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 103:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  
//Patch 0:
memchr(&cur_state, 0, sizeof(mbstate_t));

//CodeSeg 1:
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  //prophet generated patch
  if (__get_mutant()==0) {
  *good = prev;
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==1) {
  prev = (buf);
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==2) {
  prev = (p);
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==3) {
  memset(&cur_state, 0, sizeof cur_state);
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }
  else if (__get_mutant()==4) {
  prev = p;
  while (p < buf)
      {
          size_t mbclen = mbrlen(p, end - p, &cur_state);
          if (mbclen != (size_t)-2)
              prev = p;
          if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
              mbclen = 1;
              memset(&cur_state, 0, sizeof cur_state);
          }
          p += mbclen;
      }
  }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 300:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
*good = prev;
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 301:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
prev = (buf);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 302:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
prev = (p);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 303:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 304:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  
//Patch 0:
prev = p;
while (p < buf)
    {
        size_t mbclen = mbrlen(p, end - p, &cur_state);
        if (mbclen != (size_t)-2)
            prev = p;
        if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
            mbclen = 1;
            memset(&cur_state, 0, sizeof cur_state);
        }
        p += mbclen;
    }

//CodeSeg 1:

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      //prophet generated patch
      if (__get_mutant()==0) {
      prev = (buf);
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==1) {
      *good = (p);
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==2) {
      xalloc_die();
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }
      else if (__get_mutant()==3) {
      *good = prev;
      size_t mbclen = mbrlen(p, end - p, &cur_state);
      }

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building failed! Going to build saperately!
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 287:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
prev = (buf);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 288:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
*good = (p);
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 289:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
xalloc_die();
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcBasicTester, Testing instance id 290:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      
//Patch 0:
*good = prev;
size_t mbclen = mbrlen(p, end - p, &cur_state);

//CodeSeg 1:

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      //prophet generated patch
      if (__get_mutant()==0) {
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==1) {
      *good = (prev);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==2) {
      *good = prev;
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==3) {
      *good = (end);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==4) {
      *good = (p);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==5) {
      *good = (buf);
      if (mbclen != (size_t)-2)
          prev = p;
      }
      else if (__get_mutant()==6) {
      if (!(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
          if (mbclen != (size_t)-2)
              prev = p;
      }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 122:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 123:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
*good = (prev);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 124:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
*good = prev;
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 125:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
*good = (end);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 126:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
*good = (p);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 127:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
*good = (buf);
if (mbclen != (size_t)-2)
    prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
CondTester, Testing instance id 21:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      
//Patch 0:
if (!(__is_neg(7, &(mbclen), sizeof (mbclen), &(p), sizeof (p), &(prev), sizeof (prev), &(end), sizeof (end), &(buf), sizeof (buf), &(good), sizeof (good), &(match_len), sizeof (match_len))))
    if (mbclen != (size_t)-2)
        prev = p;

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Testing 0 (with abstract condition) ENVIS_NEG
Iteration 0
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Opening:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
NegativeBRANCH RECORD/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
APPENDING TO ISNEG:/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/neg.tmp!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        //prophet generated patch
        if (__get_mutant()==0) {
        {
            *good = (buf);
            prev = p;
        }
        }
        else if (__get_mutant()==1) {
        {
            *good = (p);
            prev = p;
        }
        }
        else if (__get_mutant()==2) {
        {
            prev = (buf);
            prev = p;
        }
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 274:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    *good = (buf);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 275:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    *good = (p);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 276:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        
//Patch 0:
{
    prev = (buf);
    prev = p;
}

//CodeSeg 1:

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      //prophet generated patch
      if (__get_mutant()==0) {
      mbclen = (0);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==1) {
      mbclen = (-1);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==2) {
      if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
          return 1;
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==3) {
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==4) {
      *good = (p);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==5) {
      *good = prev;
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==6) {
      *good = (prev);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      else if (__get_mutant()==7) {
      *good = (end);
      if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
          mbclen = 1;
          memset(&cur_state, 0, sizeof cur_state);
      }
      }
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 245:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (0);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 246:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
mbclen = (-1);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 247:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 248:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 249:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
*good = (p);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 250:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
*good = prev;
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 251:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
*good = (prev);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 252:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      
//Patch 0:
*good = (end);
if (mbclen == (size_t)-1 || mbclen == (size_t)-2 || mbclen == 0) {
    mbclen = 1;
    memset(&cur_state, 0, sizeof cur_state);
}

//CodeSeg 1:
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      //prophet generated patch
      if (__get_mutant()==0) {
      if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
          return 1;
      p += mbclen;
      }
      else if (__get_mutant()==1) {
      *good = (end);
      p += mbclen;
      }
      else if (__get_mutant()==2) {
      *good = (prev);
      p += mbclen;
      }
      else if (__get_mutant()==3) {
      memset(&cur_state, 0, sizeof cur_state);
      p += mbclen;
      }
      else if (__get_mutant()==4) {
      mbclen = (-1);
      p += mbclen;
      }
      else if (__get_mutant()==5) {
      *good = prev;
      p += mbclen;
      }
      else if (__get_mutant()==6) {
      *good = (buf);
      p += mbclen;
      }
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 222:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 223:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
*good = (end);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 224:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
*good = (prev);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 225:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
memset(&cur_state, 0, sizeof cur_state);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 226:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
mbclen = (-1);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 227:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
*good = prev;
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 228:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      
//Patch 0:
*good = (buf);
p += mbclen;

//CodeSeg 1:
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  //prophet generated patch
  if (__get_mutant()==0) {
  *good = (prev);
  *good = prev;
  }
  else if (__get_mutant()==1) {
  *good = (end);
  *good = prev;
  }
  else if (__get_mutant()==2) {
  prev = (p);
  *good = prev;
  }
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 202:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (prev);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 203:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
*good = (end);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 204:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  
//Patch 0:
prev = (p);
*good = prev;

//CodeSeg 1:
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	return true;
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  //prophet generated patch
  if (__get_mutant()==0) {
  prev = p;
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==1) {
  xalloc_die();
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==2) {
  prev = (p);
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==3) {
  prev = (buf);
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==4) {
  *good = prev;
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==5) {
  *good = (p);
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==6) {
  *good = (end);
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
  else if (__get_mutant()==7) {
  prev = (end);
  if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
      return 1;
  }
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 183:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
prev = p;
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 184:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
xalloc_die();
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Passed Negative Cases with BasicTester
Testing positive cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 25  > __res
Failed positive case 25
BasicTester, Testing instance id 185:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
prev = (p);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 186:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
prev = (buf);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 187:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
*good = prev;
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 188:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
*good = (p);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 189:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
*good = (end);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 190:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  
//Patch 0:
prev = (end);
if (p > buf || match_len < mbrlen(p, end - p, &cur_state))
    return 1;

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
a batched test job starts!
Building merged code:
src_file: src/searchutils.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	//prophet generated patch
  	if (__get_mutant()==0) {
  	{
  	    *good = (end);
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==1) {
  	{
  	    memset(&cur_state, 0, sizeof cur_state);
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==2) {
  	{
  	    *good = prev;
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==3) {
  	{
  	    *good = (p);
  	    return 1;
  	}
  	}
  	else if (__get_mutant()==4) {
  	{
  	    prev = (p);
  	    return 1;
  	}
  	}
}
#endif /* MBS_SUPPORT */

Building:src at:
/home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/srcMerged code building succ, going to invoke tester!
BasicTester, Testing instance id 172:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    *good = (end);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 173:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    memset(&cur_state, 0, sizeof cur_state);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 174:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    *good = prev;
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 175:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    *good = (p);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
BasicTester, Testing instance id 176:
//src_file:src/searchutils.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
/* searchutils.c - helper subroutines for grep's matchers.
   Copyright 1992, 1998, 2000, 2007, 2009-2010 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <config.h>
#include "search.h"

#define NCHAR (UCHAR_MAX + 1)

void
kwsinit (kwset_t *kwset)
{
  static char trans[NCHAR];
  int i;

  if (match_icase
#ifdef MBS_SUPPORT
      && MB_CUR_MAX == 1
#endif
     )
    {
      for (i = 0; i < NCHAR; ++i)
        trans[i] = TOLOWER (i);

      *kwset = kwsalloc (trans);
    }
  else
    *kwset = kwsalloc (NULL);

  if (!*kwset)
    xalloc_die ();
}

#ifdef MBS_SUPPORT
/* Convert the *N-byte string, BEG, to lowercase, and write the
   NUL-terminated result into malloc'd storage.  Upon success, set *N
   to the length (in bytes) of the resulting string (not including the
   trailing NUL byte), and return a pointer to the lowercase string.
   Upon memory allocation failure, this function exits.

   Note that while this function returns a pointer to malloc'd storage,
   the caller must not free it, since this function retains a pointer
   to the buffer and reuses it on any subsequent call.  As a consequence,
   this function is not thread-safe.  */
char *
mbtolower (const char *beg, size_t *n)
{
  static char *out;
  static size_t outalloc;
  size_t outlen, mb_cur_max;
  mbstate_t is, os;
  const char *end;
  char *p;

  if (*n > outalloc)
    {
      out = xrealloc (out, *n);
      outalloc = *n;
    }

  memset (&is, 0, sizeof (is));
  memset (&os, 0, sizeof (os));
  end = beg + *n;

  mb_cur_max = MB_CUR_MAX;
  p = out;
  outlen = 0;
  while (beg < end)
    {
      wchar_t wc;
      size_t mbclen = mbrtowc(&wc, beg, end - beg, &is);
      if (outlen + mb_cur_max >= outalloc)
        {
          out = x2nrealloc (out, &outalloc, 1);
          p = out + outlen;
        }

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
        {
          /* An invalid sequence, or a truncated multi-octet character.
             We treat it as a single-octet character.  */
          *p++ = *beg++;
          outlen++;
          memset (&is, 0, sizeof (is));
          memset (&os, 0, sizeof (os));
        }
      else
        {
          beg += mbclen;
          mbclen = wcrtomb (p, towlower ((wint_t) wc), &os);
          p += mbclen;
          outlen += mbclen;
        }
    }

  *n = p - out;
  *p++ = 0;
  return out;
}


bool
is_mb_middle (const char **good, const char *buf, const char *end,
	      size_t match_len)
{
  const char *p = *good;
  const char *prev = p;
  mbstate_t cur_state;

  /* TODO: can be optimized for UTF-8.  */
  memset(&cur_state, 0, sizeof(mbstate_t));
  while (p < buf)
    {
      size_t mbclen = mbrlen(p, end - p, &cur_state);

      /* Store the beginning of the previous complete multibyte character.  */
      if (mbclen != (size_t) -2)
        prev = p;

      if (mbclen == (size_t) -1 || mbclen == (size_t) -2 || mbclen == 0)
	{
	  /* An invalid sequence, or a truncated multibyte character.
	     We treat it as a single byte character.  */
	  mbclen = 1;
	  memset(&cur_state, 0, sizeof cur_state);
	}
      p += mbclen;
    }

  *good = prev;
  if (p > buf || match_len < mbrlen (p, end - p, &cur_state)) 
  	
//Patch 0:
{
    prev = (p);
    return 1;
}

//CodeSeg 1:
}
#endif /* MBS_SUPPORT */

Testing negative cases!
Running test command:
/home/ubuntu/spr-fast/tools/grep-test.py /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/src /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir/tests /home/ubuntu/spr-fast/tests/corebench/grep/grep-case-6d952bee-5fa8c7c9/tempworkdir 0  > __res
Candidate count:0!!
Repair process ends without working fix!!
Total number of compiles: 90
Total number of test eval: 595
